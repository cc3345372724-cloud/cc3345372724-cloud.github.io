<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NeuroLink OS - Mind Map</title>
    <style>
        /* === æ ¸å¿ƒæ ·å¼é‡ç½® === */
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; }
        body {
            background-color: #050508; /* æ›´æ·±é‚ƒçš„å®‡å®™é»‘ */
            color: #00ffcc;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* === ç”»å¸ƒå®¹å™¨ === */
        #canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            cursor: grab;
            background: radial-gradient(circle at center, #1a1a24 0%, #050508 100%); /* ä¼ª3DèƒŒæ™¯ */
        }
        canvas { display: block; }

        /* === UI å±‚ (æ‚¬æµ®åœ¨ç”»å¸ƒä¹‹ä¸Š) === */
        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€åˆ°ç”»å¸ƒ */
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 15px;
            z-index: 10;
        }

        /* === ä¸“å±é¡¶éƒ¨æ  (æç®€é£æ ¼) === */
        .top-bar {
            display: flex; justify-content: space-between; align-items: flex-start;
            pointer-events: auto;
        }

        /* é€€å‡ºæŒ‰é’® */
        .exit-btn {
            width: 40px; height: 40px; border-radius: 50%;
            background: rgba(255, 69, 58, 0.2); border: 1px solid #ff453a;
            color: #ff453a; font-size: 18px; display: flex; align-items: center; justify-content: center;
            cursor: pointer; backdrop-filter: blur(5px); transition: all 0.3s;
        }
        .exit-btn:active { transform: scale(0.9); background: #ff453a; color: #000; }

        /* å³ä¸Šè§’åŠŸèƒ½åŒº */
        .function-area {
            display: flex; flex-direction: column; gap: 10px; align-items: flex-end;
        }
        .func-btn {
            background: rgba(0, 255, 204, 0.1); border: 1px solid rgba(0, 255, 204, 0.3);
            color: #00ffcc; padding: 6px 12px; border-radius: 15px; font-size: 12px;
            cursor: pointer; backdrop-filter: blur(5px); pointer-events: auto;
            transition: 0.2s;
        }
        .func-btn:hover, .func-btn.active { background: rgba(0, 255, 204, 0.8); color: #000; }

        /* ç¥ç»å…ƒç±»å‹é¢æ¿ */
        .type-panel {
            background: rgba(10, 10, 18, 0.95); border: 1px solid #333;
            border-radius: 10px; padding: 10px; margin-top: 5px;
            display: none; pointer-events: auto;
        }
        .type-item {
            display: flex; align-items: center; gap: 8px; margin-bottom: 5px; font-size: 12px;
        }
        .color-dot { width: 10px; height: 10px; border-radius: 50%; }

        /* === åº•éƒ¨èŠ‚ç‚¹ä¿¡æ¯é¢æ¿ === */
        .node-info {
            background: rgba(20, 20, 30, 0.9); border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px; border-radius: 16px; pointer-events: auto;
            box-shadow: 0 0 30px rgba(0, 255, 204, 0.1);
            backdrop-filter: blur(10px);
            display: none; /* é»˜è®¤éšè— */
            margin-bottom: 20px;
            transform: translateY(20px); opacity: 0;
            transition: all 0.3s;
        }
        .node-info.show { transform: translateY(0); opacity: 1; display: block; }

        .node-title { font-size: 18px; font-weight: bold; margin-bottom: 8px; color: #fff; }
        .node-desc { font-size: 13px; color: #aaa; margin-bottom: 15px; line-height: 1.5; max-height: 100px; overflow-y: auto; }

        /* ç¥ç»åˆ†è£‚æŒ‰é’® */
        .split-btn {
            width: 100%; padding: 10px; border-radius: 8px;
            background: linear-gradient(90deg, #ff0055, #ff00cc); border: none;
            color: #fff; font-weight: bold; cursor: pointer;
            display: flex; align-items: center; justify-content: center; gap: 5px;
            box-shadow: 0 0 10px rgba(255, 0, 85, 0.4);
        }
        .split-btn:active { transform: scale(0.98); }

        /* æœç´¢/APIæ‹“å±•æ  */
        .search-bar { display: flex; gap: 8px; margin-top: 10px; }
        .search-input {
            flex: 1; background: #111; border: 1px solid #333; color: #fff;
            padding: 8px; border-radius: 6px; outline: none;
        }

        /* === è§†è§‰ç‰¹æ•ˆ === */
        .loading-pulse {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 12px; color: #00ffcc; pointer-events: none; opacity: 0; transition: opacity 0.3s;
        }

        /* å­˜å‚¨åŒºåŸŸæŒ‡ç¤ºå™¨ (æ¨¡æ‹Ÿå¤§è„‘åˆ†åŒº) */
        .brain-zone {
            position: absolute; font-size: 100px; font-weight: bold; opacity: 0.03;
            pointer-events: none; user-select: none;
        }
    </style>
</head>
<body>

    <div id="canvas-container">
        <canvas id="neuroCanvas"></canvas>

        <!-- å¤§è„‘åˆ†åŒºèƒŒæ™¯å­— -->
        <div class="brain-zone" style="top: 10%; left: 10%;">LOGIC</div>
        <div class="brain-zone" style="bottom: 10%; right: 10%;">CREATIVE</div>

        <div class="ui-layer">
            <!-- é¡¶éƒ¨æ  -->
            <div class="top-bar">
                <div class="exit-btn" onclick="goBack()">âœ•</div>
                <div class="function-area">
                    <button class="func-btn" onclick="toggleTypePanel()">ğŸ§¬ ç¥ç»å…ƒç®¡ç†</button>
                    <div class="type-panel" id="typePanel">
                        <!-- ç±»å‹åˆ—è¡¨å°†ç”± JS åŠ¨æ€ç”Ÿæˆ -->
                    </div>
                    <div style="font-size: 10px; color: #555; text-align: right;">NeuroLink v2.0</div>
                </div>
            </div>

            <div class="loading-pulse" id="loadingTip">NEURAL SYNCING...</div>

            <!-- åº•éƒ¨ä¿¡æ¯é¢æ¿ -->
            <div class="node-info" id="nodeInfoPanel">
                <div class="node-title" id="nodeTitle">èŠ‚ç‚¹åç§°</div>
                <div class="node-desc" id="nodeDesc">èŠ‚ç‚¹æè¿°å†…å®¹...</div>

                <button class="split-btn" onclick="triggerSplit()">
                    <span>âš¡ ç¥ç»åˆ†è£‚ (Neural Split)</span>
                </button>

                <div class="search-bar">
                    <input type="text" class="search-input" id="apiInput" placeholder="è¾“å…¥å…³è”è¯è¿›è¡ŒAIæ‹“å±•...">
                    <button class="func-btn" onclick="triggerAPI()">æ‹“å±•</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // === é…ç½®ä¸çŠ¶æ€ ===
        const CONFIG = {
            colors: {
                'language': '#30D158', // ç»¿è‰² (è¯­è¨€)
                'science': '#0A84FF',  // è“è‰² (ç†ç§‘)
                'entertainment': '#FF453A', // çº¢è‰² (å¨±ä¹/èµ›è½¦)
                'misc': '#BF5AF2'      // ç´«è‰² (æ‚ç‰©/è‡ªå®šä¹‰)
            },
            types: [
                { id: 'language', name: 'è¯­è¨€å­¦', color: '#30D158' },
                { id: 'science', name: 'ç†ç§‘/æŠ€æœ¯', color: '#0A84FF' },
                { id: 'entertainment', name: 'å¨±ä¹/èµ›è½¦', color: '#FF453A' },
                { id: 'misc', name: 'æ‚é¡¹/è®°å¿†', color: '#BF5AF2' }
            ]
        };

        const canvas = document.getElementById('neuroCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');

        // è§†å›¾çŠ¶æ€
        let width, height;
        let nodes = [];
        let links = [];
        let scale = 1; // ç¼©æ”¾æ¯”ä¾‹
        let offsetX = 0, offsetY = 0; // åç§»é‡
        let isDragging = false;
        let lastX, lastY;
        let selectedNode = null;

        // åŒæŒ‡ç¼©æ”¾æ”¯æŒ
        let initialDistance = 0;
        let initialScale = 1;

        // === åˆå§‹åŒ– ===
        function init() {
            resize();
            loadData(); // å°è¯•åŠ è½½æ•°æ®
            renderTypePanel();
            animate();
        }

        function resize() {
            width = container.clientWidth;
            height = container.clientHeight;
            canvas.width = width;
            canvas.height = height;
        }

        // === æ•°æ®åŠ è½½é€»è¾‘ ===
        function loadData() {
            // 1. å°è¯•ä» localStorage è·å–ä¸»APPçš„æ•°æ®
            const rawData = localStorage.getItem('mb_bubbles');
            if (rawData) {
                const bubbles = JSON.parse(rawData);
                // è½¬æ¢æ•°æ®æ ¼å¼
                nodes = bubbles.map((b, i) => ({
                    id: b.id,
                    x: (Math.random() - 0.5) * 1000, // éšæœºåˆ†å¸ƒ
                    y: (Math.random() - 0.5) * 1000,
                    r: 15 + Math.random() * 10,
                    color: getColorByType(b.text), // æ™ºèƒ½è¯†åˆ«é¢œè‰²
                    label: b.text.substring(0, 10) + (b.text.length>10?'...':''),
                    fullText: b.text,
                    desc: b.ai || 'æš‚æ— AIæ‹“å±•å†…å®¹...',
                    type: 'misc', // é»˜è®¤ä¸ºæ‚é¡¹ï¼Œåç»­å¯åŠ AIåˆ†ç±»
                    expanded: false // æ˜¯å¦å·²åˆ†è£‚
                }));
            } else {
                // æ— æ•°æ®æ—¶ç”Ÿæˆæ¼”ç¤ºæ•°æ®
                generateDemoNodes(20);
            }

            // ç”Ÿæˆéšæœºè¿æ¥ (æ¨¡æ‹Ÿç¥ç»ç½‘ç»œ)
            rebuildLinks();
        }

        function generateDemoNodes(count) {
            for (let i = 0; i < count; i++) {
                const typeObj = CONFIG.types[Math.floor(Math.random() * CONFIG.types.length)];
                nodes.push({
                    id: Date.now() + i,
                    x: (Math.random() - 0.5) * 1500,
                    y: (Math.random() - 0.5) * 1500,
                    r: 10 + Math.random() * 20,
                    color: typeObj.color,
                    label: `Node_${i}`,
                    fullText: `è¿™æ˜¯å…³äº ${typeObj.name} çš„æ ¸å¿ƒçŸ¥è¯†ç‚¹ #${i}`,
                    desc: 'ç‚¹å‡»â€œç¥ç»åˆ†è£‚â€ä»¥è·å–æ›´å¤šå…³è”ä¿¡æ¯...',
                    type: typeObj.id,
                    expanded: false
                });
            }
        }

        function rebuildLinks() {
            links = [];
            nodes.forEach((node, i) => {
                // æ¯ä¸ªèŠ‚ç‚¹éšæœºè¿æ¥ 1-3 ä¸ªæœ€è¿‘çš„é‚»å±…
                // è¿™é‡Œç®€å•å¤„ç†ä¸ºéšæœºè¿æ¥ï¼Œå®é™…å¯ç”¨ K-Nearest Neighbors
                let targets = Math.floor(Math.random() * 2) + 1;
                for (let j = 0; j < targets; j++) {
                    let targetIdx = Math.floor(Math.random() * nodes.length);
                    if (targetIdx !== i) {
                        links.push({ source: node, target: nodes[targetIdx] });
                    }
                }
            });
            document.getElementById('nodeCount') && (document.getElementById('nodeCount').innerText = nodes.length);
        }

        // ç®€å•çš„å…³é”®è¯é¢œè‰²åŒ¹é…
        function getColorByType(text) {
            if (/è¯­è¨€|è‹±è¯­|è¯æ±‡|grammar/i.test(text)) return CONFIG.colors.language;
            if (/æ•°å­¦|ç‰©ç†|å…¬å¼|ä»£ç |é€»è¾‘/i.test(text)) return CONFIG.colors.science;
            if (/èµ›è½¦|æ¸¸æˆ|ç”µå½±|éŸ³ä¹/i.test(text)) return CONFIG.colors.entertainment;
            return CONFIG.colors.misc;
        }

        // === äº¤äº’é€»è¾‘ (æ ¸å¿ƒ) ===

        // é¼ æ ‡/å•æŒ‡æ‹–æ‹½
        container.addEventListener('mousedown', startDrag);
        container.addEventListener('touchstart', e => {
            if (e.touches.length === 2) {
                // åŒæŒ‡ç¼©æ”¾å¼€å§‹
                isDragging = false;
                initialDistance = getDistance(e.touches[0], e.touches[1]);
                initialScale = scale;
            } else {
                startDrag(e.touches[0]);
            }
        });

        function startDrag(e) {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;

            // ç‚¹å‡»æ£€æµ‹
            const worldX = (e.clientX - width/2 - offsetX) / scale;
            const worldY = (e.clientY - height/2 - offsetY) / scale;
            checkClick(worldX, worldY);
        }

        container.addEventListener('mousemove', moveDrag);
        container.addEventListener('touchmove', e => {
            e.preventDefault();
            if (e.touches.length === 2) {
                // åŒæŒ‡ç¼©æ”¾ä¸­
                const dist = getDistance(e.touches[0], e.touches[1]);
                const delta = dist / initialDistance;
                scale = Math.min(Math.max(0.1, initialScale * delta), 5); // é™åˆ¶ç¼©æ”¾èŒƒå›´ 0.1x - 5x
            } else if (isDragging) {
                moveDrag(e.touches[0]);
            }
        });

        function moveDrag(e) {
            if (!isDragging) return;
            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;
            offsetX += dx;
            offsetY += dy;
            lastX = e.clientX;
            lastY = e.clientY;
        }

        container.addEventListener('mouseup', () => isDragging = false);
        container.addEventListener('touchend', () => isDragging = false);

        // æ»šè½®ç¼©æ”¾
        container.addEventListener('wheel', e => {
            e.preventDefault();
            const zoomSpeed = 0.001;
            scale += e.deltaY * -zoomSpeed;
            scale = Math.min(Math.max(0.1, scale), 5);
        }, { passive: false });

        function getDistance(t1, t2) {
            return Math.sqrt(Math.pow(t1.clientX - t2.clientX, 2) + Math.pow(t1.clientY - t2.clientY, 2));
        }

        function checkClick(wx, wy) {
            let clicked = false;
            // å€’åºéå†ï¼Œä¼˜å…ˆé€‰ä¸­ä¸Šå±‚èŠ‚ç‚¹
            for (let i = nodes.length - 1; i >= 0; i--) {
                const n = nodes[i];
                const dist = Math.sqrt((n.x - wx)**2 + (n.y - wy)**2);
                if (dist < n.r + 5/scale) { // å¢åŠ ç‚¹å‡»åˆ¤å®šå®¹é”™
                    selectNode(n);
                    clicked = true;
                    break;
                }
            }
            if (!clicked) deselectNode();
        }

        function selectNode(node) {
            selectedNode = node;
            const panel = document.getElementById('nodeInfoPanel');
            document.getElementById('nodeTitle').innerText = node.label;
            document.getElementById('nodeDesc').innerText = node.fullText + '\n\n' + node.desc;
            panel.classList.add('show');

            // èšç„¦åŠ¨ç”»
            // targetOffsetX = -node.x * scale; ... (å¯åŠ å¹³æ»‘è¿‡æ¸¡)
        }

        function deselectNode() {
            selectedNode = null;
            document.getElementById('nodeInfoPanel').classList.remove('show');
        }

        // === ç¥ç»åˆ†è£‚ (Split) é€»è¾‘ ===
        function triggerSplit() {
            if (!selectedNode) return;

            const btn = document.querySelector('.split-btn span');
            btn.innerText = "âš¡ åˆ†è£‚ä¸­ (Splitting)...";

            // æ¨¡æ‹Ÿ API å»¶è¿Ÿ
            setTimeout(() => {
                const count = 3; // åˆ†è£‚å‡º3ä¸ªå­èŠ‚ç‚¹
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 / count) * i + Math.random();
                    const dist = 100 + Math.random() * 50;

                    const child = {
                        id: Date.now() + i,
                        x: selectedNode.x + Math.cos(angle) * dist,
                        y: selectedNode.y + Math.sin(angle) * dist,
                        r: selectedNode.r * 0.8, // å­èŠ‚ç‚¹ç¨å°
                        color: selectedNode.color,
                        label: `${selectedNode.label}_sub${i}`,
                        fullText: `[åˆ†è£‚] å…³äº ${selectedNode.label} çš„å»¶ä¼¸æ€è€ƒ...`,
                        desc: 'è‡ªåŠ¨ç”Ÿæˆçš„å…³è”ç¥ç»å…ƒã€‚',
                        type: selectedNode.type,
                        expanded: false
                    };

                    nodes.push(child);
                    links.push({ source: selectedNode, target: child });
                }

                selectedNode.expanded = true;
                btn.innerText = "âš¡ ç¥ç»åˆ†è£‚ (Neural Split)";
                // æ›´æ–°è§†å›¾è¿æ¥
                // rebuildLinks(); // å¦‚æœæ˜¯pushè¿›å»çš„ï¼Œå…¶å®ä¸ç”¨å…¨é‡æ„ï¼Œç›´æ¥ç”»å°±è¡Œ
            }, 500);
        }

        function triggerAPI() {
            // æ¨¡æ‹Ÿ API æ‹“å±•ï¼Œå®é™…åº”è°ƒç”¨ GPT
            const val = document.getElementById('apiInput').value;
            if(val) {
                document.getElementById('nodeDesc').innerText += `\n\n[AI]: æ­£åœ¨ä¸ºæ‚¨æ£€ç´¢å…³äº "${val}" çš„æ·±åº¦ä¿¡æ¯... (æ¨¡æ‹Ÿ)`;
                document.getElementById('apiInput').value = '';
            }
        }

        // === æ¸²æŸ“å¾ªç¯ ===
        function animate() {
            ctx.fillStyle = '#050508';
            ctx.fillRect(0, 0, width, height);

            ctx.save();
            // åº”ç”¨å˜æ¢
            ctx.translate(width/2 + offsetX, height/2 + offsetY);
            ctx.scale(scale, scale);

            // 1. ç»˜åˆ¶è¿çº¿ (Synapses)
            ctx.lineWidth = 1.5 / scale;
            for (let link of links) {
                ctx.strokeStyle = `rgba(0, 255, 204, ${0.15 * Math.min(1, scale)})`; // è¿œçœ‹æ·¡ï¼Œè¿‘çœ‹æ¸…
                ctx.beginPath();
                ctx.moveTo(link.source.x, link.source.y);
                ctx.lineTo(link.target.x, link.target.y);
                ctx.stroke();
            }

            // 2. ç»˜åˆ¶èŠ‚ç‚¹ (Neurons)
            for (let node of nodes) {
                // å‘¼å¸åŠ¨ç”»
                const breathe = Math.sin(Date.now() * 0.002 + node.id) * 2;

                // ç»˜åˆ¶å…‰æ™•
                if (scale > 0.5) { // åªæœ‰æ”¾å¤§æ—¶æ‰ç”»å…‰æ™•ï¼Œä¼˜åŒ–æ€§èƒ½
                    const grad = ctx.createRadialGradient(node.x, node.y, node.r * 0.5, node.x, node.y, node.r * 2);
                    grad.addColorStop(0, node.color);
                    grad.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = grad;
                    ctx.globalAlpha = 0.3;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, node.r * 2 + breathe, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                }

                // ç»˜åˆ¶æ ¸å¿ƒ
                ctx.fillStyle = node.color;
                ctx.beginPath();
                ctx.arc(node.x, node.y, node.r, 0, Math.PI * 2);
                ctx.fill();

                // ç»˜åˆ¶é«˜å…‰è¾¹ç¼˜
                ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                ctx.lineWidth = 1 / scale;
                ctx.stroke();

                // é€‰ä¸­æ€
                if (node === selectedNode) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3 / scale;
                    ctx.stroke();
                    // è¿çº¿é«˜äº®
                    // (æ­¤å¤„å¯åŠ é€»è¾‘é«˜äº®ç›¸å…³è¿çº¿)
                }

                // LOD (Level of Detail) æ–‡æœ¬æ¸²æŸ“
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';

                if (scale > 1.2) {
                    // 1. å¾®è§‚æ¨¡å¼ï¼šæ˜¾ç¤ºè¯¦ç»†å†…å®¹
                    ctx.font = `${10/scale + 4}px Courier New`;
                    ctx.fillText(node.fullText.substring(0, 15), node.x, node.y + node.r + 15/scale);
                } else if (scale > 0.3) {
                    // 2. ä¸­è§‚æ¨¡å¼ï¼šæ˜¾ç¤ºæ ‡é¢˜
                    ctx.font = `${10/scale + 8}px Courier New`;
                    ctx.fillText(node.label, node.x, node.y + node.r + 10/scale);
                }
                // 3. å®è§‚æ¨¡å¼ï¼šä¸æ˜¾ç¤ºå­—ï¼Œåªæ˜¾ç¤ºç‚¹
            }

            ctx.restore();
            requestAnimationFrame(animate);
        }

        // === UI è¾…åŠ© ===
        function goBack() {
            window.location.href = 'index.html'; // è¿”å›ä¸»é¡µ
        }

        function toggleTypePanel() {
            const p = document.getElementById('typePanel');
            p.style.display = p.style.display === 'block' ? 'none' : 'block';
        }

        function renderTypePanel() {
            const container = document.getElementById('typePanel');
            container.innerHTML = '';
            CONFIG.types.forEach(t => {
                const div = document.createElement('div');
                div.className = 'type-item';
                div.innerHTML = `
                    <div class="color-dot" style="background:${t.color}"></div>
                    <input type="text" value="${t.name}" style="background:none; border:none; color:#fff; width:80px;">
                    <input type="color" value="${t.color}" onchange="updateTypeColor('${t.id}', this.value)">
                `;
                container.appendChild(div);
            });
        }

        function updateTypeColor(id, color) {
            CONFIG.colors[id] = color;
            // æ›´æ–°ç°æœ‰èŠ‚ç‚¹é¢œè‰²
            nodes.forEach(n => {
                if (n.type === id) n.color = color;
            });
        }

        window.addEventListener('resize', resize);
        init();

    </script>
</body>
</html>
