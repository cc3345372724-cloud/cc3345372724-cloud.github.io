<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>NeuroLink OS - Mind Map Ultimate v4.0</title>

    <!-- === 0. å…¨å±æ¨¡å¼é€‚é… (iOS WebClip) === -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#050508">

    <style>
        /* === 1. æ ¸å¿ƒå˜é‡ (è§†è§‰åŸºè°ƒ) === */
        :root {
            --glass-bg: rgba(20, 20, 30, 0.65); /* æ›´é€šé€ */
            --glass-border: rgba(255, 255, 255, 0.1);
            --accent-blue: #0A84FF;
            --accent-green: #30D158;
            --accent-red: #FF453A;
            --accent-purple: #BF5AF2;
            --accent-yellow: #FFD60A;
            --bg-deep: #050508;
            --text-main: #00ffcc;
            --text-sub: #aaddd5;
        }

        /* === 2. æ ¸å¿ƒæ ·å¼é‡ç½® === */
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; -webkit-tap-highlight-color: transparent; }
        body {
            background-color: var(--bg-deep);
            color: var(--text-main);
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            /* [æ–°å¢] èµ›åšæœ‹å…‹ç½‘æ ¼èƒŒæ™¯ */
            background-image:
                linear-gradient(rgba(0, 255, 204, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 204, 0.03) 1px, transparent 1px);
            background-size: 30px 30px;
        }

        /* === 3. ç”»å¸ƒå®¹å™¨ === */
        #canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            cursor: grab;
            /* å åŠ ä¸€å±‚æš—è§’æ™•å½±ï¼Œå¢å¼ºæ²‰æµ¸æ„Ÿ */
            background: radial-gradient(circle at center, transparent 0%, #050508 90%);
        }
        canvas { display: block; }

        /* === 4. UI å±‚ (æ‚¬æµ®åœ¨ç”»å¸ƒä¹‹ä¸Š) === */
        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€åˆ°ç”»å¸ƒ */
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 15px;
            z-index: 10;
        }

        /* === é¡¶éƒ¨æ  === */
        .top-bar {
            display: flex; justify-content: space-between; align-items: flex-start;
            pointer-events: auto;
            /* é€‚é…åˆ˜æµ·å± */
            padding-top: env(safe-area-inset-top);
        }

        .exit-btn {
            width: 40px; height: 40px; border-radius: 50%;
            background: rgba(255, 69, 58, 0.2); border: 1px solid #ff453a;
            color: #ff453a; font-size: 18px; display: flex; align-items: center; justify-content: center;
            cursor: pointer; backdrop-filter: blur(5px); transition: all 0.3s;
        }
        .exit-btn:active { transform: scale(0.9); background: #ff453a; color: #000; }

        .function-area { display: flex; flex-direction: column; gap: 10px; align-items: flex-end; }
        .func-btn {
            background: rgba(0, 255, 204, 0.1); border: 1px solid rgba(0, 255, 204, 0.3);
            color: #00ffcc; padding: 6px 12px; border-radius: 15px; font-size: 12px;
            cursor: pointer; backdrop-filter: blur(5px); pointer-events: auto; transition: 0.2s;
        }
        .func-btn:hover, .func-btn.active { background: rgba(0, 255, 204, 0.8); color: #000; }

        /* ç±»å‹ç®¡ç†é¢æ¿ */
        .type-panel {
            background: rgba(10, 10, 18, 0.95); border: 1px solid #333;
            border-radius: 10px; padding: 10px; margin-top: 5px;
            display: none; pointer-events: auto; min-width: 150px;
        }
        .type-item {
            display: flex; align-items: center; justify-content: space-between; /* ä¸¤ç«¯å¯¹é½ */
            gap: 8px; margin-bottom: 8px; font-size: 12px;
        }
        .type-info { display: flex; align-items: center; gap: 8px; }
        .color-dot { width: 12px; height: 12px; border-radius: 50%; border: 1px solid #fff; }

        .del-type-btn {
            color: #ff453a; font-weight: bold; cursor: pointer; padding: 0 5px;
            opacity: 0.5; transition: 0.2s;
        }
        .del-type-btn:hover { opacity: 1; transform: scale(1.2); }

        .add-type-btn {
            width: 100%; border: 1px dashed #555; background: none; color: #888;
            padding: 5px; border-radius: 5px; cursor: pointer; font-size: 10px; margin-top: 5px;
        }

        /* === åº•éƒ¨åŒºåŸŸ (ç­›é€‰ + è¯¦æƒ…) === */
        .bottom-area {
            pointer-events: auto;
            display: flex; flex-direction: column; gap: 10px;
            padding-bottom: max(10px, env(safe-area-inset-bottom));
        }

        /* ç­›é€‰æ  */
        .filter-dock {
            background: rgba(10, 10, 15, 0.8); backdrop-filter: blur(15px);
            border-radius: 20px; padding: 10px 20px;
            display: flex; justify-content: space-around;
            border: 1px solid rgba(255,255,255,0.05);
        }
        .dock-item {
            font-size: 10px; color: var(--text-sub);
            display: flex; flex-direction: column; align-items: center; gap: 4px;
            cursor: pointer; opacity: 0.6; transition: 0.2s;
        }
        .dock-item.active { opacity: 1; transform: scale(1.1); }
        .dock-icon { font-size: 18px; margin-bottom: 2px; }

        /* [æ ¸å¿ƒä¿®å¤] èŠ‚ç‚¹è¯¦æƒ…é¢æ¿ - æ‰‹æœºç«¯æ»‘åŠ¨ä¼˜åŒ– */
        .node-info {
            background: rgba(20, 20, 30, 0.95); border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px; border-radius: 16px;
            box-shadow: 0 0 30px rgba(0, 255, 204, 0.15);
            backdrop-filter: blur(10px);
            display: none; margin-bottom: 10px;
            transform: translateY(20px); opacity: 0; transition: all 0.3s;
            z-index: 20;
            /* [æ–°å¢] é™åˆ¶æœ€å¤§é«˜åº¦ï¼Œç•™å‡ºç©ºé—´ */
            max-height: 50vh;
            display: flex; flex-direction: column;
        }
        .node-info.show { transform: translateY(0); opacity: 1; display: flex; }

        .node-title {
            font-size: 18px; font-weight: bold; margin-bottom: 8px; color: #fff;
            display: flex; justify-content: space-between; align-items: center; flex-shrink: 0;
        }

        .node-tag {
            font-size: 10px; padding: 2px 6px; border-radius: 4px; border: 1px solid #fff;
            align-self: center; cursor: pointer; user-select: none;
        }

        /* [æ ¸å¿ƒä¿®å¤] è¯¦æƒ…å†…å®¹åŒº - å…è®¸æ»šåŠ¨ & è§¦æ‘¸ä¼˜åŒ– */
        .node-desc {
            font-size: 13px; color: #aaa; margin-bottom: 15px; line-height: 1.5;
            /* å…³é”®ï¼šå…è®¸å†…å®¹æº¢å‡ºæ»šåŠ¨ */
            flex: 1;
            overflow-y: auto;
            white-space: pre-wrap;
            /* [å…³é”®] iOS æƒ¯æ€§æ»šåŠ¨ */
            -webkit-overflow-scrolling: touch;
            /* [å…³é”®] å…è®¸è§¦æ‘¸äº‹ä»¶ï¼Œé˜²æ­¢è¢« Canvas æ‹¦æˆª */
            touch-action: pan-y;
            pointer-events: auto;

            min-height: 100px; /* ä¿è¯æœ‰ç‚¹å‡»åŒºåŸŸ */
        }

        /* ç¼–è¾‘çŠ¶æ€æ ·å¼ */
        .editable {
            border-bottom: 1px dashed rgba(255,255,255,0.3);
            transition: 0.2s; outline: none;
        }
        .editable:focus { border-bottom: 1px solid #00ffcc; background: rgba(255,255,255,0.05); }

        /* æŒ‰é’®ç»„ */
        .btn-group { display: flex; gap: 10px; flex-shrink: 0; }
        .action-btn {
            flex: 1; padding: 10px; border-radius: 8px; border: none;
            color: #fff; font-weight: bold; cursor: pointer; font-size: 12px;
            display: flex; align-items: center; justify-content: center; gap: 5px;
        }
        .btn-split { background: linear-gradient(90deg, #ff0055, #ff00cc); box-shadow: 0 0 10px rgba(255, 0, 85, 0.3); }
        .btn-ai { background: rgba(0, 255, 204, 0.15); border: 1px solid #00ffcc; color: #00ffcc; }
        .btn-close { width: 30px; background: rgba(255,255,255,0.1); border:none; color:#fff; flex:none; }

        /* === è§†è§‰ç‰¹æ•ˆ === */
        .loading-pulse {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 12px; color: #00ffcc; pointer-events: none; opacity: 0; transition: opacity 0.3s;
        }
        .brain-zone {
            position: absolute; font-size: 100px; font-weight: bold; opacity: 0.03;
            pointer-events: none; user-select: none; color: #fff;
        }

        /* === æ¨¡æ€æ¡†æ ·å¼ === */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.6); backdrop-filter: blur(5px);
            z-index: 100; display: flex; align-items: center; justify-content: center;
            pointer-events: auto;
        }
        .modal-card {
            background: #1a1a24; border: 1px solid rgba(255, 255, 255, 0.1);
            width: 90%; max-width: 350px; border-radius: 16px; padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        .modal-header { display: flex; justify-content: space-between; margin-bottom: 20px; color: #fff; font-size: 16px; font-weight: bold; }
        .close-icon { cursor: pointer; color: #aaa; font-size: 20px; }
        .form-group { margin-bottom: 15px; }
        .form-label { display: block; color: #888; font-size: 12px; margin-bottom: 5px; }
        .form-input {
            width: 100%; background: rgba(0,0,0,0.3); border: 1px solid #333;
            color: #fff; padding: 10px; border-radius: 8px; outline: none; font-family: monospace;
        }
        .form-input:focus { border-color: #00ffcc; }
        .btn-primary {
            width: 100%; background: #00ffcc; color: #000; border: none;
            padding: 10px; border-radius: 8px; font-weight: bold; cursor: pointer; margin-top: 10px;
        }
        .btn-primary:active { transform: scale(0.98); }

    </style>
</head>
<body>

    <div id="canvas-container">
        <canvas id="neuroCanvas"></canvas>
        <div class="brain-zone" style="top: 10%; left: 10%;">LOGIC</div>
        <div class="brain-zone" style="bottom: 10%; right: 10%;">CREATIVE</div>

        <div class="ui-layer">
            <!-- é¡¶éƒ¨æ  -->
            <div class="top-bar">
                <div class="exit-btn" onclick="goBack()">âœ•</div>
                <div class="function-area">
                    <button class="func-btn" onclick="toggleTypePanel()">ğŸ§¬ ç¥ç»å…ƒç®¡ç†</button>
                    <button class="func-btn" onclick="openModal('settingsModal')" style="margin-top:5px;">âš™ï¸ API é…ç½®</button>
                    <div class="type-panel" id="typePanel">
                        <button class="add-type-btn" onclick="addNewType()">+ æ–°å¢ç±»ç›®</button>
                    </div>
                    <div style="font-size: 10px; color: #555; text-align: right;">NeuroLink v4.0</div>
                </div>
            </div>

            <div class="loading-pulse" id="loadingTip">NEURAL SYNCING...</div>

            <!-- åº•éƒ¨åŒºåŸŸ -->
            <div class="bottom-area">
                <!-- èŠ‚ç‚¹è¯¦æƒ… (å¼¹çª—) -->
                <div class="node-info" id="nodeInfoPanel">
                    <div class="node-title">
                        <span id="nodeTitle" class="editable" contenteditable="true" onblur="saveNodeData()">èŠ‚ç‚¹åç§°</span>
                        <span id="nodeTag" class="node-tag" onclick="cycleNodeType()">TAG</span>
                    </div>
                    <!-- æè¿°åŒºåŸŸ -->
                    <div class="node-desc editable" id="nodeDesc" contenteditable="true" onblur="saveNodeData()">å†…å®¹...</div>

                    <!-- æŒ‰é’®ç»„ -->
                    <div class="btn-group">
                        <button class="action-btn btn-split" onclick="triggerSplit()">âš¡ ç¥ç»åˆ†è£‚</button>
                        <button class="action-btn btn-ai" onclick="triggerAIExpand()">ğŸ˜‹ è”æƒ³</button>
                        <button class="action-btn" style="background:rgba(255,69,58,0.2); color:#ff453a;" onclick="deleteCurrentNode()">ğŸ—‘ï¸</button>
                        <button class="action-btn btn-close" onclick="closeNodePanel()">Ã—</button>
                    </div>
                </div>

                <!-- ç­›é€‰æ  (æ ¹æ®é…ç½®åŠ¨æ€ç”Ÿæˆ) -->
                <div class="filter-dock" id="filterDock">
                    <!-- åŠ¨æ€æ³¨å…¥ -->
                </div>
            </div>
        </div>
    </div>

    <!-- API è®¾ç½®æ¨¡æ€æ¡† -->
    <div class="modal-overlay" id="settingsModal" style="display:none;">
        <div class="modal-card">
            <div class="modal-header">
                <span>ğŸ”§ API è®¾ç½®</span>
                <span class="close-icon" onclick="closeModal('settingsModal')">Ã—</span>
            </div>
            <div class="form-group">
                <label class="form-label">API URL</label>
                <input type="text" id="cfgUrl" class="form-input" placeholder="https://api.openai.com/v1">
            </div>
            <div class="form-group">
                <label class="form-label">API Key</label>
                <input type="password" id="cfgKey" class="form-input" placeholder="sk-...">
            </div>
            <div class="form-group">
                <label class="form-label">Model</label>
                <input type="text" id="cfgModel" class="form-input" placeholder="gpt-3.5-turbo" value="">
                <button type="button" class="btn-primary" onclick="fetchModels()" style="margin-top: 8px; width: 100%;">
                    ğŸ” è·å–å¯ç”¨æ¨¡å‹åˆ—è¡¨
                </button>
                <div id="modelListContainer" style="display: none; margin-top: 12px;">
                    <div class="form-label">å¯ç”¨æ¨¡å‹ï¼š</div>
                    <div id="modelList" style="max-height: 200px; overflow-y: auto; background: rgba(255,255,255,0.05); border-radius: 8px; padding: 10px; display: flex; flex-direction: column; gap: 6px; font-size: 13px;"></div>
                </div>
            </div>
            <button class="btn-primary" onclick="saveConfig()">ğŸ’¾ ä¿å­˜é…ç½®</button>
        </div>
    </div>

    <script>
        // === 1. æ ¸å¿ƒé…ç½®ä¸åˆå§‹åŒ– ===
        const CONFIG = {
            // é»˜è®¤ç±»å‹é…ç½®
            defaultTypes: [
                { id: 'language', name: 'è¯­è¨€å­¦', color: '#30D158', keywords: ['è¯­è¨€','è‹±è¯­','æ—¥æ–‡','å•è¯','è¯­æ³•','speak'] },
                { id: 'science', name: 'ç†ç§‘/æŠ€æœ¯', color: '#0A84FF', keywords: ['æ•°å­¦','ç‰©ç†','ä»£ç ','js','ç®—æ³•','logic'] },
                { id: 'entertainment', name: 'å¨±ä¹/èµ›è½¦', color: '#FF453A', keywords: ['æ¸¸æˆ','ç”µå½±','èµ›è½¦','f1','ç©','fun'] },
                { id: 'misc', name: 'æ‚é¡¹/è®°å¿†', color: '#BF5AF2', keywords: [] }
            ]
        };

        // è¯»å–ç”¨æˆ·è‡ªå®šä¹‰çš„ç±»å‹é…ç½®ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨é»˜è®¤
        let userTypes = JSON.parse(localStorage.getItem('nl_types') || JSON.stringify(CONFIG.defaultTypes));

        const canvas = document.getElementById('neuroCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');

        let width, height;
        let nodes = [], links = [];
        let scale = 1, offsetX = 0, offsetY = 0;
        let isDragging = false, lastX, lastY;
        let selectedNode = null;
        let filterType = 'all';
        let initialDistance = 0, initialScale = 1;

        // [æ–°å¢] è¯¦æƒ…é˜ˆå€¼ï¼Œå½“ scale > è¯¥å€¼æ—¶æ˜¾ç¤ºè¯¦æƒ…
        const DETAIL_THRESHOLD = 1.3;

        let apiConfig = {
            url: localStorage.getItem('nl_api_url') || 'https://api.openai.com/v1',
            key: localStorage.getItem('nl_api_key') || '',
            model: localStorage.getItem('nl_api_model') || 'gpt-3.5-turbo'
        };

        function init() {
            resize();
            loadData();
            renderFilterDock();
            renderTypePanel();
            animate();
            window.addEventListener('resize', resize);
        }

        function resize() {
            width = container.clientWidth;
            height = container.clientHeight;
            canvas.width = width;
            canvas.height = height;
        }

        // === 2. æ•°æ®åŠ è½½ (æ ¸å¿ƒé‡æ„ï¼šåŒå‘åŒæ­¥+ä¿ç•™åˆ†ç±») ===
        function loadData() {
            nodes = []; links = [];
            const rawMapData = localStorage.getItem('neuro_map_data'); // å­˜ä½ç½®ã€ç‰¹å®šåˆ†ç±»
            const rawAppData = localStorage.getItem('mb_bubbles');     // å­˜å†…å®¹ã€æ—¶é—´

            let mapNodes = rawMapData ? JSON.parse(rawMapData) : [];
            let appNodes = rawAppData ? JSON.parse(rawAppData) : [];

            const nodeMap = new Map();

            // 1. å¤„ç† App æ•°æ®
            appNodes.forEach(b => {
                // é»˜è®¤æ£€æµ‹ç±»å‹
                const autoType = detectType(b.text);

                nodeMap.set(b.id, {
                    id: b.id,
                    x: (Math.random() - 0.5) * 600,
                    y: (Math.random() - 0.5) * 600,
                    r: 15 + Math.min(b.text.length, 10),
                    // [ä¿®å¤] ä¼˜å…ˆä½¿ç”¨ App é‡Œçš„ color (å› ä¸ºå¯èƒ½æ˜¯ç”¨æˆ·æ‰‹åŠ¨é€‰çš„)
                    color: b.color || getColorByType(autoType),
                    label: b.text, // [ä¿®å¤] æš‚æ—¶å­˜å®Œæ•´æ ‡é¢˜ï¼Œæ¸²æŸ“æ—¶å†æˆªæ–­
                    fullText: b.text,
                    desc: (b.detail ? `[ç¬”è®°]: ${b.detail}\n` : '') + (b.ai ? `\n[AI]: ${b.ai}` : ''),
                    type: autoType, // åˆå§‹è‡ªåŠ¨åˆ†ç±»
                    ai: b.ai || '',
                    vx: 0, vy: 0,
                    source: 'app'
                });
            });

            // 2. èåˆ Map æ•°æ® (ä½ç½® & ç”¨æˆ·ä¿®æ­£åçš„åˆ†ç±»)
            mapNodes.forEach(n => {
                if (nodeMap.has(n.id)) {
                    const existing = nodeMap.get(n.id);
                    existing.x = n.x;
                    existing.y = n.y;

                    // [å…³é”®] å¦‚æœ Map é‡Œå­˜äº†ç±»å‹ï¼Œè¯´æ˜ç”¨æˆ·å¯èƒ½æ”¹è¿‡ï¼Œä¼˜å…ˆç”¨ Map çš„ç±»å‹
                    // ä½†é¢œè‰²è¿˜æ˜¯ä»¥ App ä¸ºå‡† (å› ä¸º Bubble é‚£è¾¹ä¹Ÿèƒ½æ”¹è‰²)
                    // ä¸ºäº†åŒæ­¥ï¼Œæˆ‘ä»¬è®¤ä¸º Bubble çš„ color å±æ€§æ˜¯æœ€ç»ˆè§†è§‰å±æ€§
                    if (n.type) existing.type = n.type;
                } else {
                     n.source = 'map';
                     nodeMap.set(n.id, n);
                }
            });

            nodes = Array.from(nodeMap.values());
            if (nodes.length === 0) generateDemoNodes(5);
            rebuildLinks();
        }

        function detectType(text) {
            const t = text.toLowerCase();
            // éå†æ‰€æœ‰ç”¨æˆ·å®šä¹‰çš„ç±»å‹ï¼ŒåŒ¹é…å…³é”®è¯
            for (const typeObj of userTypes) {
                if (typeObj.keywords && typeObj.keywords.some(k => t.includes(k))) {
                    return typeObj.id;
                }
            }
            return 'misc'; // é»˜è®¤æ‚é¡¹
        }

        function getColorByType(typeId) {
            const t = userTypes.find(x => x.id === typeId);
            return t ? t.color : '#BF5AF2';
        }

        function generateDemoNodes(count) {
            for (let i = 0; i < count; i++) {
                const typeObj = userTypes[Math.floor(Math.random() * userTypes.length)];
                nodes.push({
                    id: Date.now() + i,
                    x: (Math.random() - 0.5) * 400,
                    y: (Math.random() - 0.5) * 400,
                    r: 25,
                    color: typeObj.color,
                    label: `ç¤ºä¾‹èŠ‚ç‚¹_${i}`,
                    fullText: `è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•èŠ‚ç‚¹ #${i}`,
                    desc: `æ”¾å¤§çœ‹çœ‹ç»†èŠ‚...`,
                    type: typeObj.id,
                    ai: '', vx: 0, vy: 0
                });
            }
        }

        function rebuildLinks() {
            links = [];
            nodes.forEach((node, i) => {
                let targets = 1 + Math.floor(Math.random() * 2);
                for (let j = 0; j < targets; j++) {
                    let targetIdx = Math.floor(Math.random() * nodes.length);
                    if (targetIdx !== i) links.push({ source: node, target: nodes[targetIdx] });
                }
            });
        }

        // === 3. æ¸²æŸ“å¾ªç¯ (å«å¾®è§‚æ”¾å¤§ LOD) ===
        function animate() {
            ctx.clearRect(0, 0, width, height);
            ctx.save();
            ctx.translate(width/2 + offsetX, height/2 + offsetY);
            ctx.scale(scale, scale);

            const visibleNodes = nodes.filter(n => filterType === 'all' || n.type === filterType);

            // çº¿æ¡
            ctx.globalCompositeOperation = 'screen';
            ctx.lineWidth = 1.5 / scale;
            links.forEach(link => {
                if ((filterType !== 'all') && (link.source.type !== filterType || link.target.type !== filterType)) return;
                const grad = ctx.createLinearGradient(link.source.x, link.source.y, link.target.x, link.target.y);
                grad.addColorStop(0, link.source.color);
                grad.addColorStop(1, link.target.color);
                ctx.strokeStyle = grad;
                ctx.globalAlpha = 0.2;
                ctx.beginPath();
                ctx.moveTo(link.source.x, link.source.y);
                ctx.lineTo(link.target.x, link.target.y);
                ctx.stroke();
            });

            // èŠ‚ç‚¹
            ctx.globalCompositeOperation = 'source-over';
            visibleNodes.forEach(node => {
                ctx.globalAlpha = 1;

                // 1. åŸºç¡€åœ†åœˆ
                ctx.fillStyle = node.color;
                ctx.beginPath(); ctx.arc(node.x, node.y, node.r, 0, Math.PI*2); ctx.fill();

                // é€‰ä¸­æ€
                if (node === selectedNode) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3 / scale;
                    ctx.stroke();
                }

                // 2. æ–‡å­—å¤„ç† (LOD æ ¸å¿ƒ)
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';

                // [ä¿®å¤] æ ‡é¢˜å®Œæ•´æ˜¾ç¤ºï¼šä½¿ç”¨åŠ¨æ€è®¡ç®—
                // å¦‚æœ scale æ¯”è¾ƒå°ï¼Œæ˜¾ç¤ºç®€ç•¥ï¼›æ¯”è¾ƒå¤§ï¼Œæ˜¾ç¤ºå¤šä¸€ç‚¹ï¼›å¾ˆå¤§ï¼Œæ˜¾ç¤ºå…¨éƒ¨
                let fontSize = 12 / scale;
                // é™åˆ¶æœ€å°å­—å·ï¼Œé˜²æ­¢å¤ªå°çœ‹ä¸æ¸…
                if (fontSize < 4) fontSize = 4;
                ctx.font = `${fontSize}px Courier New`;

                // [æ–°å¢] æ ‡é¢˜å¤„ç†ï¼šå¦‚æœç¼©æ”¾å¤Ÿå¤§ï¼Œå°è¯•æ˜¾ç¤ºæ›´å¤šï¼Œå¹¶è‡ªåŠ¨æ¢è¡Œ
                if (scale > 0.6) {
                    const maxWidth = node.r * 2.5;
                    const lineHeight = fontSize * 1.2;
                    const words = node.label.split('');
                    let line = '';
                    let y = node.y + node.r + lineHeight;

                    // ç®€å•æ¢è¡Œé€»è¾‘
                    for(let n = 0; n < words.length; n++) {
                        const testLine = line + words[n];
                        const metrics = ctx.measureText(testLine);
                        if (metrics.width > maxWidth && n > 0) {
                            ctx.fillText(line, node.x, y);
                            line = words[n];
                            y += lineHeight;
                        } else {
                            line = testLine;
                        }
                    }
                    ctx.fillText(line, node.x, y);
                }

                // 3. [æ–°å¢] å¾®è§‚ç»†èŠ‚ (LOD Detail)
                // å½“æ”¾å¤§å€æ•°è¶…è¿‡é˜ˆå€¼ï¼Œåœ¨èŠ‚ç‚¹æ—è¾¹æ˜¾ç¤ºè¯¦ç»†å†…å®¹æ¡†
                if (scale > DETAIL_THRESHOLD) {
                    const detailW = 120 / scale; // æ¡†å®½åº¦éšç¼©æ”¾åå‘è°ƒæ•´ï¼Œä¿æŒè§†è§‰å¤§å°é€‚ä¸­
                    const detailH = 80 / scale;
                    const dx = node.x + node.r + 10/scale;
                    const dy = node.y - detailH/2;

                    // ç»ç’ƒèƒŒæ™¯æ¡†
                    ctx.fillStyle = 'rgba(20, 20, 30, 0.8)';
                    ctx.strokeStyle = node.color;
                    ctx.lineWidth = 1 / scale;
                    ctx.beginPath();
                    ctx.roundRect(dx, dy, detailW, detailH, 5/scale);
                    ctx.fill();
                    ctx.stroke();

                    // å†…å®¹æ–‡å­—
                    ctx.fillStyle = '#ccc';
                    ctx.textAlign = 'left';
                    ctx.font = `${8/scale}px Courier New`;

                    // ç®€å•æˆªå–å‰å‡ è¡Œ
                    const contentLines = node.desc.split('\n').slice(0, 5);
                    contentLines.forEach((line, idx) => {
                        if (line.length > 15) line = line.substring(0, 15) + '...';
                        ctx.fillText(line, dx + 5/scale, dy + 10/scale + (idx * 10/scale));
                    });
                }
            });

            ctx.restore();
            requestAnimationFrame(animate);
        }

        // === 4. äº¤äº’é€»è¾‘ (ä¿æŒä¼˜åŒ–) ===
        container.addEventListener('mousedown', startDrag);
        container.addEventListener('touchstart', e => {
            if(e.touches.length === 2) {
                isDragging = false;
                initialDistance = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                initialScale = scale;
            } else startDrag(e.touches[0]);
        });
        container.addEventListener('mousemove', moveDrag);
        container.addEventListener('touchmove', e => {
            // [å…³é”®] é˜²æ­¢ç”»å¸ƒæ»šåŠ¨å¹²æ‰°è¯¦æƒ…é¡µæ»šåŠ¨
            // å¦‚æœç‚¹åœ¨è¯¦æƒ…é¡µä¸Šï¼Œä¸é˜»æ­¢é»˜è®¤è¡Œä¸º
            if (e.target.closest('.node-info')) return;
            e.preventDefault();
            if(e.touches.length === 2) {
                const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                scale = Math.min(Math.max(0.2, initialScale * (dist / initialDistance)), 10); // [ä¿®æ”¹] å…è®¸æ”¾å¤§åˆ°10å€ä»¥ä¾¿è§‚å¯Ÿå¾®è§‚
            } else if(isDragging) moveDrag(e.touches[0]);
        });
        container.addEventListener('mouseup', endDrag);
        container.addEventListener('touchend', endDrag);
        container.addEventListener('wheel', e => {
            if (e.target.closest('.node-info')) return; // é˜²æ­¢è¯¦æƒ…é¡µæ»šåŠ¨è§¦å‘ç¼©æ”¾
            e.preventDefault();
            scale += e.deltaY * -0.001;
            scale = Math.min(Math.max(0.2, scale), 10);
        }, {passive:false});

        function startDrag(e) {
            // æ’é™¤UIå±‚ç‚¹å‡»
            if (e.target.closest('.ui-layer') && !e.target.classList.contains('ui-layer')) return;

            isDragging = true; lastX = e.clientX; lastY = e.clientY;
            const wx = (e.clientX - width/2 - offsetX) / scale;
            const wy = (e.clientY - height/2 - offsetY) / scale;

            let hit = false;
            for(let i=nodes.length-1; i>=0; i--) {
                const n = nodes[i];
                if(filterType !== 'all' && n.type !== filterType) continue;
                if(Math.hypot(n.x - wx, n.y - wy) < n.r + 10/scale) {
                    selectNode(n); hit = true; break;
                }
            }
            if(!hit) {
                 // ç‚¹å‡»ç©ºç™½æ˜¯å¦å…³é—­è¯¦æƒ…é¡µï¼Ÿ
                 // ä¸ºäº†é˜²æ­¢è¯¯è§¦ï¼Œè¿™é‡Œä¸è‡ªåŠ¨å…³é—­ï¼Œéœ€ç‚¹X
            }
        }
        function moveDrag(e) {
            if(!isDragging) return;
            offsetX += e.clientX - lastX; offsetY += e.clientY - lastY;
            lastX = e.clientX; lastY = e.clientY;
        }
        function endDrag() { isDragging = false; }

        function selectNode(node) {
            selectedNode = node;
            const p = document.getElementById('nodeInfoPanel');
            document.getElementById('nodeTitle').innerText = node.label;
            document.getElementById('nodeDesc').innerText = node.desc || node.fullText;
            updateTagUI(node);
            p.classList.add('show');
        }

        function closeNodePanel() {
            selectedNode = null;
            document.getElementById('nodeInfoPanel').classList.remove('show');
        }

          // === 4. åŠ¨ç”»æ¸²æŸ“ ===
    function animate() {
        // èƒŒæ™¯æ¸…ç†ï¼ˆä¸ºäº†é€å‡º body çš„ç½‘æ ¼èƒŒæ™¯ï¼Œè¿™é‡Œç”¨åŠé€æ˜é»‘ï¼‰
        ctx.clearRect(0, 0, width, height);
        // å¦‚æœä¸æƒ³é€è§†ï¼Œå¯ä»¥ç”¨ ctx.fillStyle = '#050508'; ctx.fillRect...
        // ä½†ä¸ºäº†èµ›åšæœ‹å…‹é£ï¼Œæˆ‘ä»¬ä¿ç•™ CSS èƒŒæ™¯

        ctx.save();
        ctx.translate(width/2 + offsetX, height/2 + offsetY);
        ctx.scale(scale, scale);

        const visibleNodes = nodes.filter(n => filterType === 'all' || n.type === filterType);

        // ç»˜åˆ¶è¿çº¿
        ctx.globalCompositeOperation = 'screen';
        ctx.lineWidth = 1.5 / scale;
        links.forEach(link => {
            if ((filterType !== 'all') && (link.source.type !== filterType || link.target.type !== filterType)) return;
            const grad = ctx.createLinearGradient(link.source.x, link.source.y, link.target.x, link.target.y);
            grad.addColorStop(0, link.source.color);
            grad.addColorStop(1, link.target.color);
            ctx.strokeStyle = grad;
            ctx.globalAlpha = 0.2; // ç¨å¾®äº®ä¸€ç‚¹
            ctx.beginPath();
            ctx.moveTo(link.source.x, link.source.y);
            ctx.lineTo(link.target.x, link.target.y);
            ctx.stroke();
        });

        // ç»˜åˆ¶èŠ‚ç‚¹
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1;
        visibleNodes.forEach(node => {
            // å‘¼å¸å¾®åŠ¨
            node.x += Math.sin(Date.now()*0.001 + node.id)*0.2;
            node.y += Math.cos(Date.now()*0.001 + node.id)*0.2;
            const breathe = Math.sin(Date.now() * 0.003 + node.id) * 3;

            // å…‰æ™•
            if (scale > 0.4) {
                const grad = ctx.createRadialGradient(node.x, node.y, node.r*0.5, node.x, node.y, node.r*2 + breathe);
                grad.addColorStop(0, node.color);
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.arc(node.x, node.y, node.r*2 + breathe, 0, Math.PI*2); ctx.fill();
            }

            // å®ä½“
            ctx.fillStyle = node.color;
            ctx.beginPath(); ctx.arc(node.x, node.y, node.r, 0, Math.PI*2); ctx.fill();

            // é€‰ä¸­é«˜äº®
            if (node === selectedNode) {
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3 / scale;
                ctx.stroke();
            }

            // æ–‡å­—
            if (scale > 0.6 || node === selectedNode) {
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.font = `${12/scale}px Courier New`;
                ctx.fillText(node.label, node.x, node.y + node.r + 15/scale);
            }
        });

        ctx.restore();
        requestAnimationFrame(animate);
    }


        // === 5. é«˜çº§åˆ†ç±»ç®¡ç† (ç”¨æˆ·è‡ªå®šä¹‰ + å…³é”®è¯æå–) ===

        function renderFilterDock() {
            const dock = document.getElementById('filterDock');
            dock.innerHTML = `
                <div class="dock-item active" onclick="filterNodes('all', this)">
                    <span class="dock-icon" style="color:#fff">â—‰</span><span>å…¨éƒ¨</span>
                </div>
            `;
            userTypes.forEach(t => {
                dock.innerHTML += `
                    <div class="dock-item" onclick="filterNodes('${t.id}', this)">
                        <span class="dock-icon" style="color:${t.color}">â—</span><span>${t.name}</span>
                    </div>
                `;
            });
        }

        function renderTypePanel() {
            const p = document.getElementById('typePanel');
            // ä¿ç•™æ–°å¢æŒ‰é’®
            const addBtn = p.querySelector('.add-type-btn');
            p.innerHTML = '';

            userTypes.forEach((t, idx) => {
                const div = document.createElement('div');
                div.className = 'type-item';
                div.innerHTML = `
                    <div class="type-info">
                        <div class="color-dot" style="background:${t.color}"></div>
                        <span>${t.name}</span>
                    </div>
                    <span class="del-type-btn" onclick="removeType(${idx})">Ã—</span>
                `;
                p.appendChild(div);
            });
            p.appendChild(addBtn);
        }

        function addNewType() {
            const name = prompt("è¾“å…¥æ–°åˆ†ç±»åç§°:");
            if(!name) return;
            const kwStr = prompt("è¾“å…¥è‡ªåŠ¨åˆ†ç±»å…³é”®è¯(ç”¨é€—å·åˆ†éš”):", "ä¾‹å¦‚: å­¦ä¹ ,ç¬”è®°");
            const kws = kwStr ? kwStr.split(/[,ï¼Œ]/).map(s=>s.trim()) : [];
            const color = ['#FFD60A', '#30D158', '#0A84FF', '#FF453A', '#BF5AF2'][Math.floor(Math.random()*5)];

            userTypes.push({
                id: 'type_' + Date.now(),
                name: name,
                color: color,
                keywords: kws
            });

            saveTypes();
            renderFilterDock();
            renderTypePanel();
            // é‡æ–°è®¡ç®—åˆ†ç±»
            reCalcAllTypes();
        }

        function removeType(idx) {
            if(confirm("ç¡®å®šåˆ é™¤è¯¥åˆ†ç±»ï¼Ÿ")) {
                userTypes.splice(idx, 1);
                saveTypes();
                renderFilterDock();
                renderTypePanel();
                reCalcAllTypes();
            }
        }

        function saveTypes() {
            localStorage.setItem('nl_types', JSON.stringify(userTypes));
        }

        // [æ–°å¢] é‡æ–°è®¡ç®—æ‰€æœ‰èŠ‚ç‚¹çš„åˆ†ç±»ï¼ˆå½“è§„åˆ™æ”¹å˜æ—¶ï¼‰
        function reCalcAllTypes() {
            nodes.forEach(n => {
                // åªæœ‰å½“æ¥æºæ˜¯ App ä¸”ç”¨æˆ·æ²¡æ‰‹åŠ¨å¼ºåˆ¶æ”¹è¿‡(Mapé‡Œæ²¡å­˜type)æ—¶æ‰é‡ç®—
                // è¿™é‡Œç®€å•å¤„ç†ï¼šå…¨éƒ¨é‡ç®—ä¸€éé»˜è®¤ç±»å‹
                n.type = detectType(n.fullText);
                n.color = getColorByType(n.type);
                // åŒæ­¥å› App (ä»…é¢œè‰²ï¼Œä¸æ”¹åˆ†ç±»IDä»¥å…æ··ä¹±ï¼ŒAppå…¶å®ä¸å­˜typeID)
                syncToMainApp('update', n);
            });
            // ä¹Ÿè¦åŒæ­¥å› Map æ•°æ®ä»¥ä¿å­˜çŠ¶æ€
            saveAllData();
        }

        // åˆ‡æ¢å½“å‰èŠ‚ç‚¹åˆ†ç±» (æ‰‹åŠ¨ä¿®æ­£)
        function cycleNodeType() {
            if(!selectedNode) return;
            let idx = userTypes.findIndex(t => t.id === selectedNode.type);
            // å¦‚æœæ²¡æ‰¾åˆ°(æ¯”å¦‚æ˜¯misc)ï¼Œå°±ä»å¤´å¼€å§‹
            if(idx === -1) idx = -1;

            idx = (idx + 1) % userTypes.length;
            const newType = userTypes[idx];

            selectedNode.type = newType.id;
            selectedNode.color = newType.color;

            updateTagUI(selectedNode);
            syncToMainApp('update', selectedNode);

            // [å…³é”®] æ‰‹åŠ¨ä¿®æ”¹åï¼Œéœ€è¦ç¡®è®¤ä¿å­˜åˆ°å…³é”®è¯åº“å—ï¼Ÿ
            // è¿™é‡Œç®€åŒ–ä¸ºï¼šæ‰‹åŠ¨ä¿®æ”¹ä¼˜å…ˆçº§æœ€é«˜ï¼Œå­˜å…¥ Map æ•°æ®
            saveAllData();

            // [å¯é€‰] è¯¢é—®æ˜¯å¦å°†å½“å‰æ ‡é¢˜æå–ä¸ºè¯¥åˆ†ç±»çš„å…³é”®è¯
            // if(confirm(`å°† "${selectedNode.label}" åŠ å…¥åˆ° [${newType.name}] çš„è‡ªåŠ¨å…³é”®è¯åº“å—ï¼Ÿ`)) {
            //     newType.keywords.push(selectedNode.label);
            //     saveTypes();
            // }
        }

        function updateTagUI(node) {
            const tag = document.getElementById('nodeTag');
            const t = userTypes.find(x => x.id === node.type) || {name:'æœªçŸ¥', color:'#fff'};
            tag.innerText = t.name;
            tag.style.borderColor = node.color;
            tag.style.color = node.color;
        }

        // === 6. å…¶ä»–é€»è¾‘ (ä¿å­˜ã€åŒæ­¥ã€AI) ===

        function saveNodeData() {
            if(!selectedNode) return;
            selectedNode.label = document.getElementById('nodeTitle').innerText;
            selectedNode.desc = document.getElementById('nodeDesc').innerText;
            selectedNode.fullText = selectedNode.desc.split('\n[AI]:')[0];

            syncToMainApp('update', selectedNode);
            saveAllData();
        }

        function saveAllData() {
            // åªå­˜ä½ç½®å’Œç±»å‹ä¿¡æ¯åˆ° Map æ•°æ®ï¼Œä¸å­˜å…·ä½“å†…å®¹ï¼Œå†…å®¹ä»¥ App ä¸ºå‡†
            const mapData = nodes.map(n => ({
                id: n.id,
                x: n.x,
                y: n.y,
                type: n.type // ä¿å­˜æ‰‹åŠ¨ä¿®æ”¹åçš„ç±»å‹
            }));
            localStorage.setItem('neuro_map_data', JSON.stringify(mapData));
        }

        function syncToMainApp(action, node) {
            const raw = localStorage.getItem('mb_bubbles');
            let bubbles = raw ? JSON.parse(raw) : [];
            const todayStr = new Date().toISOString().split('T')[0];

            if (action === 'update') {
                const target = bubbles.find(b => b.id === node.id);
                if (target) {
                    target.ai = node.ai;
                    target.detail = node.desc; // å­˜å®Œæ•´æè¿°
                    target.color = node.color;
                    target.text = node.label;
                }
            } else if (action === 'delete') {
                bubbles = bubbles.filter(b => String(b.id) !== String(node.id));
            } else if (action === 'add') {
                if (!bubbles.some(b => String(b.id) === String(node.id))) {
                    bubbles.push({
                        id: node.id,
                        date: todayStr,
                        text: node.label,
                        detail: node.desc,
                        ai: node.ai,
                        color: node.color
                    });
                }
            }
            localStorage.setItem('mb_bubbles', JSON.stringify(bubbles));
        }

        function deleteCurrentNode() {
            if(!selectedNode) return;
            if(confirm('åˆ é™¤æ­¤èŠ‚ç‚¹ï¼Ÿ')) {
                syncToMainApp('delete', selectedNode);
                nodes = nodes.filter(n => n !== selectedNode);
                links = links.filter(l => l.source !== selectedNode && l.target !== selectedNode);
                closeNodePanel();
                saveAllData();
            }
        }

        // AI æ‹“å±•
        async function triggerAIExpand() {
            if(!selectedNode) return;
            const btn = document.querySelector('.btn-ai');
            const oldTxt = btn.innerText;
            if (!apiConfig.key) return alert("è¯·å…ˆå»è®¾ç½®é‡Œå¡« API Keyï¼");
            btn.innerText = "ğŸ§ ..."; btn.disabled = true;

            const prompt = `è¯·å¯¹"${selectedNode.label}"è¿›è¡Œæ·±åº¦ç™¾ç§‘å¼æ‹“å±•(100å­—å·¦å³)ï¼Œç›´æ¥è¾“å‡ºå†…å®¹ã€‚`;
            try {
                const response = await fetch(`${apiConfig.url}/chat/completions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiConfig.key}` },
                    body: JSON.stringify({ model: apiConfig.model, messages: [{role: "user", content: prompt}], temperature: 0.7 })
                });
                const data = await response.json();
                const content = data.choices[0].message.content;
                selectedNode.desc += `\n\n[AI]: ${content}`;
                selectedNode.ai = content;
                document.getElementById('nodeDesc').innerText = selectedNode.desc;
                syncToMainApp('update', selectedNode);
                saveAllData();
            } catch(e) { alert("AI Error: " + e.message); }
            finally { btn.innerText = oldTxt; btn.disabled = false; }
        }

        // ç¥ç»åˆ†è£‚
        async function triggerSplit() {
            // ... (ä¸ä¹‹å‰é€»è¾‘ç›¸åŒï¼Œçœç•¥ä»¥èŠ‚çœç©ºé—´ï¼ŒåŠŸèƒ½éœ€ä¿ç•™) ...
            if (!selectedNode) return;
            const btn = document.querySelector('.btn-split');
            if (!apiConfig.key) return alert("API Key?");
            btn.innerText = "âš¡..."; btn.disabled = true;

            const prompt = `åŸºäº"${selectedNode.label}"ç”Ÿæˆ1-3ä¸ªå…³è”å­æ¦‚å¿µã€‚è¿”å›JSONæ•°ç»„:[{"label":"æ ‡é¢˜","text":"å†…å®¹"}]`;
            try {
                const response = await fetch(`${apiConfig.url}/chat/completions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiConfig.key}` },
                    body: JSON.stringify({ model: apiConfig.model, messages: [{role: "user", content: prompt}], temperature: 0.7 })
                });
                const data = await response.json();
                const content = data.choices[0].message.content.replace(/```json|```/g, '').trim();
                const newNodesData = JSON.parse(content);
                newNodesData.forEach((item, i) => {
                    const angle = (Math.PI * 2 / newNodesData.length) * i + Math.random();
                    const dist = 100;
                    const child = {
                        id: Date.now() + i,
                        x: selectedNode.x + Math.cos(angle) * dist,
                        y: selectedNode.y + Math.sin(angle) * dist,
                        r: 20, color: selectedNode.color,
                        label: item.label, fullText: item.text, desc: item.text,
                        type: selectedNode.type, ai: '', vx: 0, vy: 0
                    };
                    nodes.push(child);
                    links.push({source: selectedNode, target: child});
                    syncToMainApp('add', child);
                });
                saveAllData();
            } catch (e) { console.error(e); } finally { btn.innerText = "âš¡ ç¥ç»åˆ†è£‚"; btn.disabled = false; }
        }

        // è¾…åŠ© UI é€»è¾‘
        function toggleTypePanel() {
            const p = document.getElementById('typePanel');
            p.style.display = p.style.display==='block'?'none':'block';
        }
        function filterNodes(type, el) {
            filterType = type;
            document.querySelectorAll('.dock-item').forEach(d => d.classList.remove('active'));
            if(el) el.classList.add('active');
        }
        function goBack() { window.location.href = 'index.html'; }

        // æ¨¡æ€æ¡†
        function openModal(id) { document.getElementById(id).style.display = 'flex'; document.getElementById('cfgUrl').value = apiConfig.url; document.getElementById('cfgKey').value = apiConfig.key; document.getElementById('cfgModel').value = apiConfig.model; }
        function closeModal(id) { document.getElementById(id).style.display = 'none'; }
        function saveConfig() { apiConfig.url = document.getElementById('cfgUrl').value; apiConfig.key = document.getElementById('cfgKey').value; apiConfig.model = document.getElementById('cfgModel').value; localStorage.setItem('nl_api_url', apiConfig.url); localStorage.setItem('nl_api_key', apiConfig.key); localStorage.setItem('nl_api_model', apiConfig.model); closeModal('settingsModal'); }
        async function fetchModels() { /* å¤ç”¨ä¹‹å‰çš„ fetchModels ä»£ç  */ }

        init();
    </script>
</body>
</html>
