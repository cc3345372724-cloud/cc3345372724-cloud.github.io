<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>NeuroLink OS - Mind Map Ultimate</title>

    <!-- === 0. å…¨å±æ¨¡å¼é€‚é… (iOS WebClip) === -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <!-- è®¾ç½®çŠ¶æ€æ æ ·å¼ä¸ºé»‘è‰²é€æ˜ (è®©å†…å®¹é¡¶ä¸Šå») -->
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#050508">

    <style>
        /* === 1. æ ¸å¿ƒå˜é‡ (è§†è§‰åŸºè°ƒ) === */
        :root {
            --glass-bg: rgba(20, 20, 30, 0.85);
            --glass-border: rgba(255, 255, 255, 0.1);
            --accent-blue: #0A84FF;
            --accent-green: #30D158;
            --accent-red: #FF453A;
            --accent-purple: #BF5AF2;
            --accent-yellow: #FFD60A;
            --bg-deep: #050508;
        }

        /* === 2. æ ¸å¿ƒæ ·å¼é‡ç½® === */
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; -webkit-tap-highlight-color: transparent; }
        body {
            background-color: var(--bg-deep);
            color: #00ffcc;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* === 3. ç”»å¸ƒå®¹å™¨ === */
        #canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            cursor: grab;
            background: radial-gradient(circle at center, #1a1a24 0%, #050508 100%); /* ä¼ª3DèƒŒæ™¯ */
        }
        canvas { display: block; }

        /* === 4. UI å±‚ (æ‚¬æµ®åœ¨ç”»å¸ƒä¹‹ä¸Š) === */
        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€åˆ°ç”»å¸ƒ */
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 15px;
            z-index: 10;
        }

        /* === é¡¶éƒ¨æ  === */
        .top-bar {
            display: flex; justify-content: space-between; align-items: flex-start;
            pointer-events: auto;
            /* é€‚é…åˆ˜æµ·å± */
            padding-top: env(safe-area-inset-top);
        }

        .exit-btn {
            width: 40px; height: 40px; border-radius: 50%;
            background: rgba(255, 69, 58, 0.2); border: 1px solid #ff453a;
            color: #ff453a; font-size: 18px; display: flex; align-items: center; justify-content: center;
            cursor: pointer; backdrop-filter: blur(5px); transition: all 0.3s;
        }
        .exit-btn:active { transform: scale(0.9); background: #ff453a; color: #000; }

        .function-area { display: flex; flex-direction: column; gap: 10px; align-items: flex-end; }
        .func-btn {
            background: rgba(0, 255, 204, 0.1); border: 1px solid rgba(0, 255, 204, 0.3);
            color: #00ffcc; padding: 6px 12px; border-radius: 15px; font-size: 12px;
            cursor: pointer; backdrop-filter: blur(5px); pointer-events: auto; transition: 0.2s;
        }
        .func-btn:hover, .func-btn.active { background: rgba(0, 255, 204, 0.8); color: #000; }

        /* ç±»å‹ç®¡ç†é¢æ¿ */
        .type-panel {
            background: rgba(10, 10, 18, 0.95); border: 1px solid #333;
            border-radius: 10px; padding: 10px; margin-top: 5px;
            display: none; pointer-events: auto; min-width: 150px;
        }
        .type-item {
            display: flex; align-items: center; justify-content: space-between; /* ä¸¤ç«¯å¯¹é½ */
            gap: 8px; margin-bottom: 8px; font-size: 12px;
        }
        .type-info { display: flex; align-items: center; gap: 8px; }
        .color-dot { width: 12px; height: 12px; border-radius: 50%; border: 1px solid #fff; }

        .del-type-btn {
            color: #ff453a; font-weight: bold; cursor: pointer; padding: 0 5px;
            opacity: 0.5; transition: 0.2s;
        }
        .del-type-btn:hover { opacity: 1; transform: scale(1.2); }

        .add-type-btn {
            width: 100%; border: 1px dashed #555; background: none; color: #888;
            padding: 5px; border-radius: 5px; cursor: pointer; font-size: 10px; margin-top: 5px;
        }

        /* === åº•éƒ¨åŒºåŸŸ (ç­›é€‰ + è¯¦æƒ…) === */
        .bottom-area {
            pointer-events: auto;
            display: flex; flex-direction: column; gap: 10px;
            padding-bottom: max(10px, env(safe-area-inset-bottom));
        }

        /* ç­›é€‰æ  */
        .filter-dock {
            background: rgba(10, 10, 15, 0.8); backdrop-filter: blur(15px);
            border-radius: 20px; padding: 10px 20px;
            display: flex; justify-content: space-around;
            border: 1px solid rgba(255,255,255,0.05);
        }
        .dock-item {
            font-size: 10px; color: var(--text-sub);
            display: flex; flex-direction: column; align-items: center; gap: 4px;
            cursor: pointer; opacity: 0.6; transition: 0.2s;
        }
        .dock-item.active { opacity: 1; transform: scale(1.1); }
        .dock-icon { font-size: 18px; margin-bottom: 2px; }

        /* èŠ‚ç‚¹è¯¦æƒ…é¢æ¿ (é»˜è®¤éšè—) */
        .node-info {
            background: rgba(20, 20, 30, 0.95); border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px; border-radius: 16px;
            box-shadow: 0 0 30px rgba(0, 255, 204, 0.15);
            backdrop-filter: blur(10px);
            display: none; margin-bottom: 10px;
            transform: translateY(20px); opacity: 0; transition: all 0.3s;
            z-index: 20;
        }
        .node-info.show { transform: translateY(0); opacity: 1; display: block; }

        .node-title { font-size: 18px; font-weight: bold; margin-bottom: 8px; color: #fff; display: flex; justify-content: space-between; align-items: center; }

        .node-tag {
            font-size: 10px; padding: 2px 6px; border-radius: 4px; border: 1px solid #fff;
            align-self: center; cursor: pointer; user-select: none;
        }

        /* [ä¿®å¤] è¯¦æƒ…å¯æ»‘åŠ¨ï¼Œé™åˆ¶é«˜åº¦ */
        .node-desc {
            font-size: 13px; color: #aaa; margin-bottom: 15px; line-height: 1.5;
            max-height: 300px; /* é™åˆ¶æœ€å¤§é«˜åº¦ */
            overflow-y: auto;  /* è¶…å‡ºéƒ¨åˆ†æ»šåŠ¨ */
            white-space: pre-wrap; /* ä¿ç•™æ¢è¡Œ */
        }

        /* ç¼–è¾‘çŠ¶æ€æ ·å¼ */
        .editable {
            border-bottom: 1px dashed rgba(255,255,255,0.3);
            transition: 0.2s; outline: none;
        }
        .editable:focus { border-bottom: 1px solid #00ffcc; background: rgba(255,255,255,0.05); }

        /* AI ç»“æœæ¡† */
        .ai-box {
            background: rgba(0, 255, 204, 0.05); border-left: 2px solid #00ffcc;
            padding: 10px; font-size: 12px; color: #aaddd5; margin-bottom: 15px;
            display: none; white-space: pre-wrap;
        }

        /* æŒ‰é’®ç»„ */
        .btn-group { display: flex; gap: 10px; }
        .action-btn {
            flex: 1; padding: 10px; border-radius: 8px; border: none;
            color: #fff; font-weight: bold; cursor: pointer; font-size: 12px;
            display: flex; align-items: center; justify-content: center; gap: 5px;
        }
        .btn-split { background: linear-gradient(90deg, #ff0055, #ff00cc); box-shadow: 0 0 10px rgba(255, 0, 85, 0.3); }
        .btn-ai { background: rgba(0, 255, 204, 0.15); border: 1px solid #00ffcc; color: #00ffcc; }
        .btn-close { width: 30px; background: rgba(255,255,255,0.1); border:none; color:#fff; flex:none; }

        /* === è§†è§‰ç‰¹æ•ˆ === */
        .loading-pulse {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 12px; color: #00ffcc; pointer-events: none; opacity: 0; transition: opacity 0.3s;
        }
        .brain-zone {
            position: absolute; font-size: 100px; font-weight: bold; opacity: 0.03;
            pointer-events: none; user-select: none; color: #fff;
        }
        
        /* === [æ–°å¢] æ¨¡æ€æ¡†æ ·å¼ === */
.modal-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.6); backdrop-filter: blur(5px);
    z-index: 100; display: flex; align-items: center; justify-content: center;
    pointer-events: auto; /* ç¡®ä¿èƒ½ç‚¹å‡» */
}
.modal-card {
    background: #1a1a24; border: 1px solid rgba(255, 255, 255, 0.1);
    width: 90%; max-width: 350px; border-radius: 16px; padding: 20px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
}
.modal-header { display: flex; justify-content: space-between; margin-bottom: 20px; color: #fff; font-size: 16px; font-weight: bold; }
.close-icon { cursor: pointer; color: #aaa; font-size: 20px; }
.form-group { margin-bottom: 15px; }
.form-label { display: block; color: #888; font-size: 12px; margin-bottom: 5px; }
.form-input {
    width: 100%; background: rgba(0,0,0,0.3); border: 1px solid #333;
    color: #fff; padding: 10px; border-radius: 8px; outline: none; font-family: monospace;
}
.form-input:focus { border-color: #00ffcc; }
.btn-primary {
    width: 100%; background: #00ffcc; color: #000; border: none;
    padding: 10px; border-radius: 8px; font-weight: bold; cursor: pointer; margin-top: 10px;
}
.btn-primary:active { transform: scale(0.98); }
.model-item { padding: 8px; border-radius: 4px; cursor: pointer; color: #ddd; }
.model-item:hover { background: rgba(255,255,255,0.1); }

    </style>
</head>
<body>

    <div id="canvas-container">
        <canvas id="neuroCanvas"></canvas>
        <div class="brain-zone" style="top: 10%; left: 10%;">LOGIC</div>
        <div class="brain-zone" style="bottom: 10%; right: 10%;">CREATIVE</div>

        <div class="ui-layer">
            <!-- é¡¶éƒ¨æ  -->
            <div class="top-bar">
                <div class="exit-btn" onclick="goBack()">âœ•</div>
                <div class="function-area">
                    <button class="func-btn" onclick="toggleTypePanel()">ğŸ§¬ ç¥ç»å…ƒç®¡ç†</button>
                    <button class="func-btn" onclick="openModal('settingsModal')" style="margin-top:5px;">âš™ï¸ API é…ç½®</button>
                    <div class="type-panel" id="typePanel">
                        <!-- JS åŠ¨æ€ç”Ÿæˆ -->
                        <button class="add-type-btn" onclick="addNewType()">+ æ–°å¢ç±»ç›®</button>
                    </div>
                    <div style="font-size: 10px; color: #555; text-align: right;">NeuroLink v3.1</div>
                </div>
            </div>

            <div class="loading-pulse" id="loadingTip">NEURAL SYNCING...</div>

            <!-- åº•éƒ¨åŒºåŸŸ -->
            <div class="bottom-area">
                <!-- èŠ‚ç‚¹è¯¦æƒ… (å¼¹çª—) -->
                <div class="node-info" id="nodeInfoPanel">
                    <div class="node-title">
                        <!-- æ ‡é¢˜å¯ç¼–è¾‘ -->
                        <span id="nodeTitle" class="editable" contenteditable="true" onblur="saveNodeData()">èŠ‚ç‚¹åç§°</span>
                        <!-- ç‚¹å‡»åˆ‡æ¢TAG -->
                        <span id="nodeTag" class="node-tag" onclick="cycleNodeType()">TAG</span>
                    </div>
                    <!-- æè¿°å¯ç¼–è¾‘ -->
                    <div class="node-desc editable" id="nodeDesc" contenteditable="true" onblur="saveNodeData()">å†…å®¹...</div>
                    <div class="ai-box" id="aiResultBox"></div>

<div class="btn-group">

    <button class="action-btn btn-split" onclick="triggerSplit()">âš¡ ç¥ç»åˆ†è£‚</button>

    <button class="action-btn btn-ai" onclick="triggerAIExpand()">ğŸ˜‹ è”æƒ³</button>


    <button class="action-btn" style="background:rgba(255,69,58,0.2); color:#ff453a;" onclick="deleteCurrentNode()">ğŸ—‘ï¸</button>
    <button class="action-btn btn-close" onclick="closeNodePanel()">Ã—</button>
                   </div>
                </div>

                <!-- ç­›é€‰æ  -->
                <div class="filter-dock">
                    <div class="dock-item active" onclick="filterNodes('all', this)">
                        <span class="dock-icon" style="color:#fff">â—‰</span><span>å…¨éƒ¨</span>
                    </div>
                    <div class="dock-item" onclick="filterNodes('language', this)">
                        <span class="dock-icon" style="color:var(--accent-green)">â—</span><span>è¯­è¨€</span>
                    </div>
                    <div class="dock-item" onclick="filterNodes('science', this)">
                        <span class="dock-icon" style="color:var(--accent-blue)">â—</span><span>ç†ç§‘</span>
                    </div>
                    <div class="dock-item" onclick="filterNodes('entertainment', this)">
                        <span class="dock-icon" style="color:var(--accent-red)">â—</span><span>å¨±ä¹</span>
                    </div>
                    <div class="dock-item" onclick="filterNodes('misc', this)">
                        <span class="dock-icon" style="color:var(--accent-purple)">â—</span><span>æ‚é¡¹</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- apiè®¾ç½®éƒ¨åˆ† -->
    <div class="modal-overlay" id="settingsModal" style="display:none;">
    <div class="modal-card">
        <div class="modal-header">
            <span>ğŸ”§ API è®¾ç½®</span>
            <span class="close-icon" onclick="closeModal('settingsModal')">Ã—</span>
        </div>
        <div class="form-group">
            <label class="form-label">API URL</label>
            <input type="text" id="cfgUrl" class="form-input" placeholder="https://api.openai.com/v1">
        </div>
        <div class="form-group">
            <label class="form-label">API Key</label>
            <input type="password" id="cfgKey" class="form-input" placeholder="sk-...">
        </div>
        <div class="form-group">
            <label class="form-label">Model</label>
            <input type="text" id="cfgModel" class="form-input" placeholder="gpt-3.5-turbo" value="">
            <button type="button" class="btn-primary" onclick="fetchModels()" style="margin-top: 8px; width: 100%;">
                ğŸ” è·å–å¯ç”¨æ¨¡å‹åˆ—è¡¨
            </button>
            <div id="modelListContainer" style="display: none; margin-top: 12px;">
                <div class="form-label">å¯ç”¨æ¨¡å‹ï¼š</div>
                <div id="modelList" style="max-height: 200px; overflow-y: auto; background: rgba(255,255,255,0.05); border-radius: 8px; padding: 10px; display: flex; flex-direction: column; gap: 6px; font-size: 13px;"></div>
            </div>
        </div>
        <button class="btn-primary" onclick="saveConfig()">ğŸ’¾ ä¿å­˜é…ç½®</button>
    </div>
</div>


    <script>
        // === 1. æ ¸å¿ƒé…ç½®ä¸çŠ¶æ€ ===
        const CONFIG = {
            colors: {
                'language': '#30D158',
                'science': '#0A84FF',
                'entertainment': '#FF453A',
                'misc': '#BF5AF2',
                'custom': '#FFD60A'
            },
            types: [
                { id: 'language', name: 'è¯­è¨€å­¦', color: '#30D158' },
                { id: 'science', name: 'ç†ç§‘/æŠ€æœ¯', color: '#0A84FF' },
                { id: 'entertainment', name: 'å¨±ä¹/èµ›è½¦', color: '#FF453A' },
                { id: 'misc', name: 'æ‚é¡¹/è®°å¿†', color: '#BF5AF2' }
            ]
        };

        const canvas = document.getElementById('neuroCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');

        let width, height;
        let nodes = [], links = [];
        let scale = 1, offsetX = 0, offsetY = 0;
        let isDragging = false, lastX, lastY;
        let selectedNode = null;
        let filterType = 'all'; // å½“å‰ç­›é€‰ç±»å‹
        let initialDistance = 0, initialScale = 1; // åŒæŒ‡ç¼©æ”¾

        // === [æ–°å¢] API é…ç½®å˜é‡ ===
let apiConfig = {
    url: localStorage.getItem('nl_api_url') || 'https://api.openai.com/v1',
    key: localStorage.getItem('nl_api_key') || '',
    model: localStorage.getItem('nl_api_model') || 'gpt-3.5-turbo'
};


        // === 2. åˆå§‹åŒ– ===
        function init() {
            resize();
            loadData();
            renderTypePanel();
            animate();
            window.addEventListener('resize', resize);
        }

        function resize() {
            width = container.clientWidth;
            height = container.clientHeight;
            canvas.width = width;
            canvas.height = height;
        }

        // === 3. æ•°æ®åŠ è½½ä¸å¤„ç† ===
        function loadData() {
            const rawData = localStorage.getItem('mb_bubbles'); // è¯»å–ä¸»APPæ•°æ®
            if (rawData) {
                const bubbles = JSON.parse(rawData);
                nodes = bubbles.map(b => {
                    const type = detectType(b.text);
                    return {
                        id: b.id,
                        x: (Math.random() - 0.5) * 800,
                        y: (Math.random() - 0.5) * 800,
                        r: 10 + Math.min(b.text.length, 10),
                        color: CONFIG.colors[type],
                        label: b.text.substring(0, 8) + (b.text.length>8?'...':''),
                        fullText: b.text,
                        desc: b.ai || 'æš‚æ— è¯¦ç»†æè¿°...',
                        type: type,
                        ai: b.ai || '',
                        vx: 0, vy: 0 // ç‰©ç†å¼•æ“é€Ÿåº¦
                    };
                });
            } else {
                generateDemoNodes(15);
            }
            rebuildLinks();
        }

        function detectType(text) {
            const t = text.toLowerCase();
            if (/è¯­è¨€|è‹±è¯­|æ—¥æ–‡|å•è¯|è¯­æ³•|speak/i.test(t)) return 'language';
            if (/æ•°å­¦|ç‰©ç†|ä»£ç |js|ç®—æ³•|logic/i.test(t)) return 'science';
            if (/æ¸¸æˆ|ç”µå½±|èµ›è½¦|f1|ç©|fun/i.test(t)) return 'entertainment';
            return 'misc'; // é»˜è®¤ä¸ºæ‚é¡¹
        }

        function generateDemoNodes(count) {
            for (let i = 0; i < count; i++) {
                const typeObj = CONFIG.types[Math.floor(Math.random() * CONFIG.types.length)];
                nodes.push({
                    id: Date.now() + i,
                    x: (Math.random() - 0.5) * 1000,
                    y: (Math.random() - 0.5) * 1000,
                    r: 15 + Math.random() * 10,
                    color: typeObj.color,
                    label: `ç¤ºä¾‹_${i}`,
                    fullText: `è¿™æ˜¯å…³äº ${typeObj.name} çš„æµ‹è¯•èŠ‚ç‚¹ #${i}`,
                    desc: 'ç‚¹å‡»â€œåˆ†è£‚â€æŒ‰é’®æµ‹è¯•åŠ¨ç”»æ•ˆæœ...',
                    type: typeObj.id,
                    ai: '', vx: 0, vy: 0
                });
            }
        }

        function rebuildLinks() {
            links = [];
            nodes.forEach((node, i) => {
                let targets = 1 + Math.floor(Math.random() * 2); // éšæœºè¿ 1-2 ä¸ª
                for (let j = 0; j < targets; j++) {
                    let targetIdx = Math.floor(Math.random() * nodes.length);
                    if (targetIdx !== i) links.push({ source: node, target: nodes[targetIdx] });
                }
            });
        }

        // === 4. æ¸²æŸ“å¼•æ“ (èåˆäº†ä»£ç 2çš„ç‚«é…·æ•ˆæœ) ===
        function animate() {
            ctx.fillStyle = '#050508';
            ctx.fillRect(0, 0, width, height);

            ctx.save();
            ctx.translate(width/2 + offsetX, height/2 + offsetY);
            ctx.scale(scale, scale);

            // ç­›é€‰é€»è¾‘ï¼šåªæ¸²æŸ“ç¬¦åˆç±»å‹çš„èŠ‚ç‚¹
            const visibleNodes = nodes.filter(n => filterType === 'all' || n.type === filterType);

            // ç»˜åˆ¶è¿çº¿
            ctx.globalCompositeOperation = 'screen';
            ctx.lineWidth = 1.5 / scale;
            links.forEach(link => {
                if ((filterType !== 'all') && (link.source.type !== filterType || link.target.type !== filterType)) return;
                const grad = ctx.createLinearGradient(link.source.x, link.source.y, link.target.x, link.target.y);
                grad.addColorStop(0, link.source.color);
                grad.addColorStop(1, link.target.color);
                ctx.strokeStyle = grad;
                ctx.globalAlpha = 0.15;
                ctx.beginPath();
                ctx.moveTo(link.source.x, link.source.y);
                ctx.lineTo(link.target.x, link.target.y);
                ctx.stroke();
            });

            // ç»˜åˆ¶èŠ‚ç‚¹
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1;
            visibleNodes.forEach(node => {
                node.x += Math.sin(Date.now()*0.001 + node.id)*0.3;
                node.y += Math.cos(Date.now()*0.001 + node.id)*0.3;
                const breathe = Math.sin(Date.now() * 0.003 + node.id) * 3;

                if (scale > 0.4) {
                    const grad = ctx.createRadialGradient(node.x, node.y, node.r*0.5, node.x, node.y, node.r*2 + breathe);
                    grad.addColorStop(0, node.color);
                    grad.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath(); ctx.arc(node.x, node.y, node.r*2 + breathe, 0, Math.PI*2); ctx.fill();
                }

                ctx.fillStyle = node.color;
                ctx.beginPath(); ctx.arc(node.x, node.y, node.r, 0, Math.PI*2); ctx.fill();

                if (node === selectedNode) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3 / scale;
                    ctx.stroke();
                }

                if (scale > 0.5 || node === selectedNode) {
                    ctx.fillStyle = '#fff';
                    ctx.textAlign = 'center';
                    ctx.font = `${12/scale}px Courier New`;
                    ctx.fillText(node.label, node.x, node.y + node.r + 15/scale);
                }
            });

            ctx.restore();
            requestAnimationFrame(animate);
        }

        // === 5. äº¤äº’é€»è¾‘ (é”å®šä¼˜åŒ–) ===
        container.addEventListener('mousedown', startDrag);
        container.addEventListener('touchstart', e => {
            if(e.touches.length === 2) {
                isDragging = false;
                initialDistance = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                initialScale = scale;
            } else startDrag(e.touches[0]);
        });
        container.addEventListener('mousemove', moveDrag);
        container.addEventListener('touchmove', e => {
            e.preventDefault();
            if(e.touches.length === 2) {
                const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                scale = Math.min(Math.max(0.2, initialScale * (dist / initialDistance)), 5);
            } else if(isDragging) moveDrag(e.touches[0]);
        });
        container.addEventListener('mouseup', endDrag);
        container.addEventListener('touchend', endDrag);
        container.addEventListener('wheel', e => {
            e.preventDefault();
            scale += e.deltaY * -0.001;
            scale = Math.min(Math.max(0.2, scale), 5);
        }, {passive:false});

        function startDrag(e) {
            isDragging = true; lastX = e.clientX; lastY = e.clientY;
            const wx = (e.clientX - width/2 - offsetX) / scale;
            const wy = (e.clientY - height/2 - offsetY) / scale;

            let hit = false;
            for(let i=nodes.length-1; i>=0; i--) {
                const n = nodes[i];
                if(filterType !== 'all' && n.type !== filterType) continue;
                if(Math.hypot(n.x - wx, n.y - wy) < n.r + 10/scale) {
                    selectNode(n); hit = true; break;
                }
            }
            // æ ¸å¿ƒä¿®æ”¹ï¼šç‚¹å‡»ç©ºç™½å¤„ä¸å†å…³é—­å¼¹çª—ï¼
            // if(!hit) deselectNode(); // åˆ æ‰è¿™è¡Œ
        }
        function moveDrag(e) {
            if(!isDragging) return;
            offsetX += e.clientX - lastX; offsetY += e.clientY - lastY;
            lastX = e.clientX; lastY = e.clientY;
        }
        function endDrag() { isDragging = false; }

        function selectNode(node) {
            selectedNode = node;
            const p = document.getElementById('nodeInfoPanel');
            document.getElementById('nodeTitle').innerText = node.label;
            document.getElementById('nodeDesc').innerText = node.fullText; // æ˜¾ç¤ºå…¨å
            updateTagUI(node);

            const aiBox = document.getElementById('aiResultBox');
            if(node.ai) { aiBox.style.display = 'block'; aiBox.innerText = node.ai; }
            else { aiBox.style.display = 'none'; }

            p.classList.add('show');
        }

        // ä¸“é—¨çš„å…³é—­å‡½æ•°
        function closeNodePanel() {
            selectedNode = null;
            document.getElementById('nodeInfoPanel').classList.remove('show');
            document.getElementById('nodeTitle').blur();
            document.getElementById('nodeDesc').blur();
        }

        // === 6. æ ¸å¿ƒåŠŸèƒ½ (ç¼–è¾‘/åˆ é™¤/Tagåˆ‡æ¢) ===

        function saveNodeData() {
            if(!selectedNode) return;
            selectedNode.label = document.getElementById('nodeTitle').innerText;
            selectedNode.fullText = document.getElementById('nodeDesc').innerText;
        }

    function cycleNodeType() {
        if(!selectedNode) return;
        let idx = CONFIG.types.findIndex(t => t.id === selectedNode.type);
        idx = (idx + 1) % CONFIG.types.length;
        const newType = CONFIG.types[idx];

        // æ›´æ–°å†…å­˜
        selectedNode.type = newType.id;
        selectedNode.color = newType.color;
        updateTagUI(selectedNode);

        // [æ–°å¢ä¿®å¤]ï¼šç«‹åˆ»åŒæ­¥åˆ°ä¸» App å’Œæœ¬åœ°å­˜å‚¨
        // å› ä¸º syncToMainApp æœ¬æ¥å°±æ”¯æŒ update é¢œè‰²
        syncToMainApp('update', selectedNode);
        saveAllData();
    }

    // ä¿®æ”¹ syncToMainApp ä»¥æ”¯æŒé¢œè‰²æ›´æ–° (åŸä»£ç å·²æœ‰ï¼Œç¡®è®¤ä¸€ä¸‹)
    function syncToMainApp(action, node) {
        // ...
        if (action === 'update') {
            const target = bubbles.find(b => b.id === node.id);
            if (target) {
                target.ai = node.ai;
                target.detail = node.fullText;
                target.color = node.color; // [ç¡®è®¤] è¿™é‡Œä¼šæ›´æ–°é¢œè‰²
                // [æ–°å¢] å¦‚æœä¿®æ”¹äº† typeï¼Œå¯èƒ½ä¹Ÿéœ€è¦è®°å½•ï¼Ÿ
                // å¦‚æœä¸» App ä¸å­˜ type å­—æ®µï¼Œé‚£å°±åªèƒ½é  color åŒºåˆ†
            }
        }

        function updateTagUI(node) {
            const tag = document.getElementById('nodeTag');
            tag.innerText = node.type.toUpperCase();
            tag.style.borderColor = node.color;
            tag.style.color = node.color;
        }

        function renderTypePanel() {
            const c = document.getElementById('typePanel');
            const btn = c.querySelector('.add-type-btn');
            c.innerHTML = '';
            CONFIG.types.forEach((t, index) => {
                const d = document.createElement('div');
                d.className = 'type-item';
                // å…è®¸åˆ é™¤ç±»ç›®ï¼ˆè‡³å°‘ä¿ç•™ä¸€ä¸ªï¼‰
                const delBtn = CONFIG.types.length > 1 ? `<span class="del-type-btn" onclick="removeType(${index})">Ã—</span>` : '';
                d.innerHTML = `
                    <div class="type-info"><div class="color-dot" style="background:${t.color}"></div><span>${t.name}</span></div>
                    ${delBtn}
                `;
                c.appendChild(d);
            });
            c.appendChild(btn);
        }

        function removeType(index) {
            if(confirm('ç¡®å®šåˆ é™¤è¯¥ç±»ç›®å—ï¼Ÿå…³è”èŠ‚ç‚¹å°†å½’å…¥â€œæ‚é¡¹â€ã€‚')) {
                const typeId = CONFIG.types[index].id;
                CONFIG.types.splice(index, 1);
                nodes.forEach(n => {
                    if(n.type === typeId) { n.type = 'misc'; n.color = CONFIG.colors.misc; }
                });
                renderTypePanel();
                if(filterType === typeId) filterNodes('all', document.querySelector('.dock-item'));
            }
        }
// === [æ ¸å¿ƒä¿®æ”¹] çœŸå® API åˆ†è£‚é€»è¾‘ ===
async function triggerSplit() {
    if (!selectedNode) return;
    const btn = document.querySelector('.btn-split');
    const originalText = btn.innerText;

    // 1. æ£€æŸ¥ API é…ç½®
    if (!apiConfig.key) {
        alert("è¯·å…ˆç‚¹å‡»å³ä¸Šè§’ã€âš™ï¸ API é…ç½®ã€‘è®¾ç½® API Keyï¼");
        return;
    }

    // 2. é”å®šæŒ‰é’®çŠ¶æ€
    btn.innerText = "âš¡ æ­£åœ¨è£‚å˜...";
    btn.disabled = true;

    // 3. æ„å»º Prompt
    const prompt = `ä½ æ˜¯ä¸€ä¸ªæ€ç»´å¯¼å›¾åŠ©æ‰‹å’ŒçŸ¥è¯†åº“ï¼ˆä¿è¯çŸ¥è¯†å‡†ç¡®ï¼‰ã€‚è¯·æ ¹æ®æ ¸å¿ƒæ¦‚å¿µ"${selectedNode.label}"(è¯¦ç»†å†…å®¹:"${selectedNode.fullText}")ï¼Œè¿›è¡Œæ€ç»´å‘æ•£å’Œç›¸å…³æ‹“å±•ã€‚
    è¦æ±‚ï¼š
    1. ç”Ÿæˆ 1-3 ä¸ªå…³è”çŸ¥è¯†ç‚¹ï¼ˆä½œä¸ºå­èŠ‚ç‚¹ï¼‰ã€‚
    2. æ¯ä¸ªçŸ¥è¯†ç‚¹åŒ…å«ï¼šæ ‡é¢˜(labelï¼Œç®€çŸ­)ã€è¯¦ç»†å†…å®¹(fullTextï¼Œçº¦100å­—)ã€‚
    3. è¿”å›æ ¼å¼å¿…é¡»æ˜¯çº¯ JSON æ•°ç»„ï¼Œä¾‹å¦‚ï¼š[{"label":"æ ‡é¢˜1","fullText":"å†…å®¹1"},...]ã€‚ä¸è¦åŒ…å« markdown æ ¼å¼æˆ–å…¶ä»–åºŸè¯ã€‚`;

    try {
        // 4. å‘èµ·è¯·æ±‚
        const response = await fetch(`${apiConfig.url}/chat/completions`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiConfig.key}`
            },
            body: JSON.stringify({
                model: apiConfig.model,
                messages: [{role: "user", content: prompt}],
                temperature: 0.7
            })
        });

        if (!response.ok) throw new Error(`API Error: ${response.status}`);
        const data = await response.json();
        const content = data.choices[0].message.content;

        // 5. è§£æ JSON (å°è¯•æ¸…ç†å¯èƒ½å­˜åœ¨çš„ markdown æ ‡è®°)
        const cleanJson = content.replace(/```json|```/g, '').trim();
        const newNodesData = JSON.parse(cleanJson);

        // 6. ç”Ÿæˆæ–°èŠ‚ç‚¹

            newNodesData.forEach((item, i) => {
                const angle = (Math.PI * 2 / newNodesData.length) * i + Math.random();
                const dist = 80 + Math.random() * 40;

                const child = {
                    id: Date.now() + i, // ç¡®ä¿ ID å”¯ä¸€æ€§
                    x: selectedNode.x,
                    y: selectedNode.y,
                    r: 15 + Math.min(item.fullText.length, 5),
                    color: selectedNode.color,
                    label: item.label,
                    // [æ–°å¢] ç¡®ä¿ detail å†…å®¹ä¹Ÿè¢«å­˜å…¥ fullText
                    fullText: item.fullText || item.label,
                    desc: 'AI Generated',
                    type: selectedNode.type,
                    ai: '', vx: 0, vy: 0,
                    source: 'ai_split' // æ ‡è®°ä¸€ä¸‹
                };

                nodes.push(child);
                links.push({source: selectedNode, target: child});

                // ä»…åœ¨è¿™é‡Œæ·»åŠ åˆ°æš‚å­˜æ•°ç»„ï¼Œç¨åç»Ÿä¸€åŒæ­¥æˆ–å°±åœ¨è¿™é‡ŒåŒæ­¥
                newChildNodes.push(child);

                // åŠ¨ç”»å¼¹å°„
                setTimeout(() => {
                    child.x += Math.cos(angle) * dist;
                    child.y += Math.sin(angle) * dist;
                }, 50);
            });

            // [ä¿®å¤æ ¸å¿ƒ]ï¼šä¸è¦åœ¨ä¸Šé¢çš„ foreach å¤–é¢å†æ¥ä¸€ä¸ª newNodesData.forEach
            // åŸä»£ç é‡Œä¼¼ä¹æœ‰ä¸¤æ®µ forEach å¤„ç† newNodesDataï¼Œå¯¼è‡´é‡å¤ã€‚
            // ç›´æ¥åœ¨è¿™é‡ŒåŒæ­¥åˆ°ä¸» App
            newChildNodes.forEach(node => {
                syncToMainApp('add', node);
            });

            // ä¿å­˜
            saveAllData();
            alert(`æˆåŠŸåˆ†è£‚å‡º ${newNodesData.length} ä¸ªæ–°æƒ³æ³•ï¼`);

        } catch (e) {
        console.error(e);
        alert("åˆ†è£‚å¤±è´¥ï¼šè¯·æ£€æŸ¥ç½‘ç»œæˆ–APIé…ç½®ã€‚\n" + e.message);
    } finally {
        btn.innerText = originalText;
        btn.disabled = false;
    }
}
// === [æ ¸å¿ƒä¿®æ”¹] çœŸÂ·AI æ‹“å±• (å†…å®¹å†…åŒ–ç‰ˆ) ===
async function triggerAIExpand() {
    if(!selectedNode) return;
    const btn = document.querySelector('.btn-ai');
    const oldTxt = btn.innerText;

    if (!apiConfig.key) return alert("è¯·å…ˆå»è®¾ç½®é‡Œå¡« API Keyï¼");

    btn.innerText = "ğŸ§  å†™å…¥ä¸­...";
    btn.disabled = true;

    const prompt = `è¯·å¯¹æ¦‚å¿µ"${selectedNode.label}"è¿›è¡Œæ·±åº¦ç™¾ç§‘å¼æ‹“å±•(100-300å­—)ï¼Œç›´æ¥è¾“å‡ºå†…å®¹ï¼Œä¸è¦åºŸè¯ã€‚`;

    try {
        const response = await fetch(`${apiConfig.url}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiConfig.key}` },
            body: JSON.stringify({
                model: apiConfig.model,
                messages: [{role: "user", content: prompt}],
                temperature: 0.7
            })
        });
        const data = await response.json();
        const content = data.choices[0].message.content;

        // [å…³é”®] å†…å®¹å†…åŒ–ï¼šç›´æ¥è¿½åŠ åˆ° fullText
        selectedNode.fullText += `\n\n--- [AI æ‹“å±•] ---\n${content}`;
        selectedNode.ai = content; // ç•™ä¸ªå¤‡ä»½ä¹Ÿè¡Œ

        // æ›´æ–° UIï¼šç›´æ¥æ˜¾ç¤ºåœ¨æ­£æ–‡åŒºï¼Œä¸å†éœ€è¦é‚£ä¸ª aiResultBox
        document.getElementById('nodeDesc').innerText = selectedNode.fullText;
        // å¦‚æœæ‚¨æƒ³éšè—é‚£ä¸ªç»¿è‰²çš„ ai-boxï¼Œå¯ä»¥åœ¨ CSS é‡ŒæŠŠå®ƒ display:noneï¼Œæˆ–è€…è¿™é‡Œç½®ç©º
        document.getElementById('aiResultBox').style.display = 'none';

        // åŒæ­¥å¹¶ä¿å­˜
        syncToMainApp('update', selectedNode);
        saveAllData();

        alert("AI çŸ¥è¯†å·²æ³¨å…¥å¤§è„‘çš®å±‚ï¼(å·²è¿½åŠ åˆ°èŠ‚ç‚¹å†…å®¹)");

    } catch(e) {
        alert("AI ç½¢å·¥äº†ï¼š" + e.message);
    } finally {
        btn.innerText = oldTxt;
        btn.disabled = false;
    }
}



        function filterNodes(type, el) {
            filterType = type;
            document.querySelectorAll('.dock-item').forEach(d => d.classList.remove('active'));
            if(el) el.classList.add('active');
        }

        function toggleTypePanel() {
            const p = document.getElementById('typePanel');
            p.style.display = p.style.display==='block'?'none':'block';
        }

        function addNewType() {
            const name = prompt("è¾“å…¥æ–°ç±»ç›®åç§°:");
            if(name) {
                const id = 'custom_' + Date.now();
                const color = CONFIG.colors.custom;
                CONFIG.types.push({id, name, color});
                CONFIG.colors[id] = color;
                renderTypePanel();
            }
        }

        // === [æ–°å¢] è¾…åŠ©åŠŸèƒ½å‡½æ•°åº“ ===

// 1. åˆ é™¤èŠ‚ç‚¹
        // === [ä¿®æ”¹] åˆ é™¤èŠ‚ç‚¹ (åŒå‘) ===
function deleteCurrentNode() {
    if(!selectedNode) return;
    if(confirm(`ç¡®å®šè¦å½»åº•åˆ é™¤ "${selectedNode.label}" å—ï¼Ÿ\n(ä¸» App é‡Œçš„å¯¹åº”è®°å½•ä¹Ÿä¼šæ¶ˆå¤±ï¼)`)) {
        // 1. åŒæ­¥åˆ é™¤ä¸» App æ•°æ®
        syncToMainApp('delete', selectedNode);

        // 2. æœ¬åœ°åˆ é™¤
        nodes = nodes.filter(n => n !== selectedNode);
        links = links.filter(l => l.source !== selectedNode && l.target !== selectedNode);

        closeNodePanel();
        saveAllData();
    }
}


// 2. å…¨å±€ä¿å­˜ (å†™å…¥ localStorage)
function saveAllData() {
    // ç®€åŒ–æ•°æ®ç»“æ„ä»¥èŠ‚çœç©ºé—´
    const simpleData = nodes.map(n => ({
        id: n.id, text: n.fullText, ai: n.ai,
        // è¿™é‡Œçš„é€»è¾‘éœ€è¦æ ¹æ®ä¸»Appçš„æ•°æ®ç»“æ„é€‚é…ï¼Œå¦‚æœä¸»Appåªè®¤ text/idï¼Œé‚£è¿™é‡Œå°±åªå­˜è¿™äº›
        // å¦‚æœè¦å®Œå…¨æŒä¹…åŒ–è„‘å›¾ç»“æ„ï¼Œå»ºè®®å­˜ä¸€ä¸ªå•ç‹¬çš„ keyï¼Œæ¯”å¦‚ 'neuro_map_data'
    }));
    // è¿™é‡Œä¸ºäº†å…¼å®¹ä¸»Appï¼Œå‡è®¾è¿˜æ˜¯å­˜å› mb_bubblesï¼Œä½†å…¶å®æœ€å¥½æ˜¯å­˜ä¸¤ä»½
    // å’±ä»¬è¿™é‡Œåªæ¼”ç¤ºå­˜å›ä¸»Keyï¼Œæ³¨æ„ï¼šè¿™å¯èƒ½ä¼šè¦†ç›–ä¸»Appçš„å…¶ä»–éè„‘å›¾æ•°æ®ï¼Œæ…ç”¨ï¼
    // å»ºè®®ï¼šå¦‚æœåªæ˜¯è„‘å›¾è‡ªå·±çš„æ•°æ®ï¼Œç”¨ 'neuro_map_data'
    localStorage.setItem('neuro_map_data', JSON.stringify(nodes));
}
// æ³¨æ„ï¼šloadData å‡½æ•°ä¹Ÿè¦å¯¹åº”ä¿®æ”¹ï¼Œä¼˜å…ˆè¯»å– neuro_map_data

// 3. API è®¾ç½®ç›¸å…³
function openModal(id) {
    document.getElementById(id).style.display = 'flex';
    // å¡«å……å½“å‰é…ç½®
    document.getElementById('cfgUrl').value = apiConfig.url;
    document.getElementById('cfgKey').value = apiConfig.key;
    document.getElementById('cfgModel').value = apiConfig.model;
}
function closeModal(id) { document.getElementById(id).style.display = 'none'; }

function saveConfig() {
    apiConfig.url = document.getElementById('cfgUrl').value.replace(/\/$/, '');
    apiConfig.key = document.getElementById('cfgKey').value;
    apiConfig.model = document.getElementById('cfgModel').value;

    localStorage.setItem('nl_api_url', apiConfig.url);
    localStorage.setItem('nl_api_key', apiConfig.key);
    localStorage.setItem('nl_api_model', apiConfig.model);

    closeModal('settingsModal');
    alert("é…ç½®å·²ä¿å­˜ï¼");
}

async function fetchModels() {
    // ... (æ­¤å¤„ç›´æ¥ä½¿ç”¨æ‚¨æä¾›çš„ fetchModels ä»£ç ï¼Œé€»è¾‘å®Œå…¨ä¸€è‡´ï¼Œä¸å†é‡å¤ç²˜è´´) ...
    // è®°å¾—æŠŠ fetchModels é‡Œçš„ DOM ID å’Œè¿™é‡Œçš„ HTML å¯¹åº”ä¸Š
}
        // === [Patch] ä¿®æ­£åçš„æ•°æ®åŠ è½½é€»è¾‘ ===

        function loadData() {
            // 1. åˆå§‹åŒ–ç©ºæ•°ç»„
            nodes = [];
            links = [];

            // 2. è¯»å–ä¸¤ä»½æ•°æ®æº
            // source A: è„‘å›¾åŸç”Ÿæ•°æ® (ä¼˜å…ˆçº§é«˜ï¼ŒåŒ…å«ä½ç½®ä¿¡æ¯)
            const rawMapData = localStorage.getItem('neuro_map_data');
            // source B: ä¸»Appæ•°æ® (æ‚¨çš„å®è´µé—äº§)
            const rawAppData = localStorage.getItem('mb_bubbles');

            let mapNodes = [];
            let appNodes = [];

            // 3. è§£æè„‘å›¾åŸç”Ÿæ•°æ®
            if (rawMapData) {
                try {
                    mapNodes = JSON.parse(rawMapData);
                } catch(e) { console.error("è„‘å›¾æ•°æ®æŸå", e); }
            }

            // 4. è§£æå¹¶è½¬æ¢ä¸»Appæ•°æ®
            if (rawAppData) {
                try {
                    const bubbles = JSON.parse(rawAppData);
                    // è½¬æ¢æ ¸å¿ƒï¼šæŠŠ Bubble å˜æˆ Node
                    appNodes = bubbles.map((b, i) => {
                        // æ™ºèƒ½ç±»å‹æ£€æµ‹ (ä¿æŒé¢œè‰²ä¸€è‡´)
                        const type = detectType(b.text);

                        return {
                            id: b.id, // ä¿æŒ ID ä¸€è‡´ï¼Œæ–¹ä¾¿å»é‡
                            // å¦‚æœæ˜¯æ–°æ•°æ®ï¼Œç»™ä¸ªéšæœºä½ç½®ï¼›å¦‚æœæ˜¯æ—§æ•°æ®ï¼Œç¨åä¼šè¢« mapNodes è¦†ç›–
                            x: (Math.random() - 0.5) * 600,
                            y: (Math.random() - 0.5) * 600,
                            r: 15 + Math.min(b.text.length, 10),
                            color: b.color || CONFIG.colors[type] || '#BF5AF2', // ä¼˜å…ˆç”¨ä¸»Appçš„é¢œè‰²
                            label: b.text.length > 8 ? b.text.substring(0, 8) + '...' : b.text,
                            fullText: b.text,
                            // æ•´åˆ detail å’Œ ai å­—æ®µ
                            desc: (b.detail ? `[ç¬”è®°]: ${b.detail}\n` : '') + (b.ai ? `\n[AI]: ${b.ai}` : 'æš‚æ— è¯¦ç»†æè¿°...'),
                            type: type,
                            ai: b.ai || '',
                            vx: 0, vy: 0,
                            source: 'app' // æ ‡è®°æ¥æº
                        };
                    });
                } catch(e) { console.error("ä¸»Appæ•°æ®è§£æå¤±è´¥", e); }
            }

            // 5. æ•°æ®èåˆ (Merge)
            // ç­–ç•¥ï¼šä»¥ App æ•°æ®ä¸ºåŸºç¡€ï¼Œå¦‚æœ Map æ•°æ®é‡Œæœ‰ä½ç½®ä¿¡æ¯ï¼Œå°±æ›´æ–°ä½ç½®
            // è¿™æ ·æ—¢èƒ½çœ‹åˆ°æ–°åŠ çš„ Bubbleï¼Œåˆèƒ½ä¿ç•™æ‹–æ‹½åçš„ä½ç½®

            // åˆ›å»ºä¸€ä¸ª Map æ–¹ä¾¿æŸ¥æ‰¾ï¼ŒKey æ˜¯ ID
            const nodeMap = new Map();

            // å…ˆæŠŠ App çš„æ•°æ®æ”¾è¿›å»
            appNodes.forEach(n => nodeMap.set(n.id, n));

            // å†æŠŠ Map çš„æ•°æ®è¦†ç›–è¿›å» (ä¸»è¦æ˜¯ä½ç½® x,y å’Œ links)
            mapNodes.forEach(n => {
                if (nodeMap.has(n.id)) {
                    // å¦‚æœ ID å­˜åœ¨ï¼Œæ›´æ–°ä½ç½®å’Œç‰¹å®šå±æ€§ï¼Œä¿ç•™ App çš„æœ€æ–°æ–‡æœ¬
                    const existing = nodeMap.get(n.id);
                    existing.x = n.x;
                    existing.y = n.y;
                    existing.expanded = n.expanded; // æ¯”å¦‚æ˜¯å¦å·²åˆ†è£‚
                } else {
                    // å¦‚æœ App é‡Œæ²¡äº†ï¼ˆè¢«åˆ äº†ï¼‰ä½† Map é‡Œè¿˜æœ‰...
                    // ç­–ç•¥ï¼šçœ‹æ‚¨å–œå¥½ï¼Œè¿™é‡Œé»˜è®¤ä¿ç•™ï¼Œé˜²æ­¢è¯¯åˆ 
                    // æ ‡è®°ä¸ºè„‘å›¾ç‰¹æœ‰
                    n.source = 'map';
                    nodeMap.set(n.id, n);
                }
            });

            // è½¬å›æ•°ç»„
            nodes = Array.from(nodeMap.values());

            // 6. å¦‚æœå®Œå…¨æ²¡æ•°æ®ï¼Œæç‚¹ Demo
            if (nodes.length === 0) {
                generateDemoNodes(10);
            }

            // 7. é‡å»ºè¿æ¥ (ç®€å•çš„ä¸´è¿‘è¿æ¥ï¼Œè®©å›¾çœ‹èµ·æ¥ä¸æ•£)
            // æ³¨æ„ï¼šçœŸå®çš„è¿æ¥å…³ç³»åº”è¯¥å­˜èµ·æ¥ï¼Œè¿™é‡Œä¸ºäº†çœäº‹æ¯æ¬¡é‡ç®—ä¸€ééšæœºè¿æ¥
            // å¦‚æœæ‚¨å¸Œæœ›è¿æ¥å…³ç³»ä¹ŸæŒä¹…åŒ–ï¼Œéœ€è¦æŠŠ links ä¹Ÿå­˜è¿› localStorage
            rebuildLinks();
        }

        // [è¾…åŠ©] ç±»å‹æ£€æµ‹ (ä¿æŒä¸å˜)
        function detectType(text) {
            const t = text.toLowerCase();
            if (/è¯­è¨€|è‹±è¯­|æ—¥æ–‡|å•è¯|è¯­æ³•|speak/i.test(t)) return 'language';
            if (/æ•°å­¦|ç‰©ç†|ä»£ç |js|ç®—æ³•|logic/i.test(t)) return 'science';
            if (/æ¸¸æˆ|ç”µå½±|èµ›è½¦|f1|ç©|fun/i.test(t)) return 'entertainment';
            return 'misc';
        }

        // [è¾…åŠ©] æ¯æ¬¡åŠ è½½é‡ç½®è¿æ¥ (å¯æ”¹ä¸ºä»å­˜å‚¨è¯»å–)
        function rebuildLinks() {
            links = [];
            // ç®€å•çš„éšæœºè¿çº¿ï¼Œæ¨¡æ‹Ÿç¥ç»ç½‘ç»œ
            // ä¼˜åŒ–ï¼šåªè¿æ¥åŒç±»å‹çš„ï¼Œæˆ–è€…è·ç¦»è¿‘çš„
            nodes.forEach((node, i) => {
                // æ¯ä¸ªèŠ‚ç‚¹å°è¯•è¿æ¥ 1-2 ä¸ªé‚»å±…
                let targets = 1 + Math.floor(Math.random() * 2);
                for (let j = 0; j < targets; j++) {
                    let targetIdx = Math.floor(Math.random() * nodes.length);
                    if (targetIdx !== i) {
                        // ç®€å•é˜²é‡
                        links.push({ source: node, target: nodes[targetIdx] });
                    }
                }
            });
        }

        // [Patch] ä¿å­˜é€»è¾‘ä¹Ÿè¦å¾®è°ƒï¼Œé˜²æ­¢æŠŠ App çš„æ•°æ®å†™å
        // æˆ‘ä»¬åªä¿å­˜â€œä½ç½®â€å’Œâ€œè„‘å›¾ç‰¹æœ‰å±æ€§â€åˆ° neuro_map_data
        // App çš„åŸç”Ÿæ•°æ® (text, color) ä¸åœ¨è¿™é‡Œæ”¹ï¼Œé™¤éæ‚¨æƒ³åŒå‘åŒæ­¥

        function saveAllData() {
            // å­˜å®Œæ•´çš„ä¸€ä»½åˆ° neuro_map_dataï¼Œä½œä¸ºè„‘å›¾çš„â€œå­˜æ¡£â€
            // è¿™æ ·ä¸‹æ¬¡è¿›æ¥ï¼Œä½ç½®å°±è¢«è®°ä½äº†
            localStorage.setItem('neuro_map_data', JSON.stringify(nodes));

            // æç¤ºï¼šç›®å‰æ˜¯å•å‘åŒæ­¥ (App -> Map)
            // å¦‚æœåœ¨ Map é‡Œæ”¹äº†å­—ï¼ŒApp ä¸ä¼šå˜ã€‚æƒ³å˜çš„è¯å¾—åå‘å†™å› mb_bubblesï¼Œæœ‰ç‚¹é£é™©ã€‚
            // å»ºè®®ï¼šè„‘å›¾ä½œä¸ºâ€œæŸ¥çœ‹+å‘æ•£â€å·¥å…·ï¼Œä¿®æ”¹è¿˜æ˜¯å›ä¸»é¡µæ”¹æ¯”è¾ƒå®‰å…¨ã€‚
        }


// === [æ–°å¢] åŒå‘åŒæ­¥æ ¸å¿ƒå‡½æ•° ===
// === [ä¿®å¤] åŒå‘åŒæ­¥ (é˜²é‡ + ä¸¥è°¨åˆ é™¤) ===
function syncToMainApp(action, node) {
    const raw = localStorage.getItem('mb_bubbles');
    let bubbles = raw ? JSON.parse(raw) : [];
    const todayStr = new Date().toISOString().split('T')[0];

    if (action === 'update') {
        const target = bubbles.find(b => b.id === node.id);
        if (target) {
            target.ai = node.ai;
            target.detail = node.fullText; // åŒæ­¥æ­£æ–‡
            target.color = node.color;     // åŒæ­¥é¢œè‰²
        }
    } else if (action === 'delete') {
        // [ä¿®å¤] ç¡®ä¿ç±»å‹ä¸€è‡´å†åˆ  (ID å¯èƒ½æ˜¯æ•°å­—æˆ–å­—ç¬¦ä¸²)
        bubbles = bubbles.filter(b => String(b.id) !== String(node.id));
    } else if (action === 'add') {
        // [å…³é”®ä¿®å¤] é˜²é‡æ£€æŸ¥ï¼å¦‚æœ ID å·²å­˜åœ¨ï¼Œç»å¯¹ä¸ Pushï¼
        const exists = bubbles.some(b => String(b.id) === String(node.id));
        if (!exists) {
            bubbles.push({
                id: node.id,
                date: todayStr,
                text: node.label, // æ ‡é¢˜
                detail: node.fullText, // æ­£æ–‡
                ai: node.ai,
                color: node.color
            });
        }
    }

    localStorage.setItem('mb_bubbles', JSON.stringify(bubbles));
}


        function goBack() { window.location.href = 'index.html'; }

        init();
    </script>
</body>
</html>






